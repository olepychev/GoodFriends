{
  "version": 3,
  "sources": ["../../@egjs/component/src/utils.ts", "../../@egjs/component/src/ActualComponentEvent.ts", "../../@egjs/component/src/Component.ts", "../../@egjs/component/src/ComponentEvent.ts", "../../@egjs/component/src/index.ts", "../../@cfcs/core/src/core/utils.ts", "../../@cfcs/core/src/dom/utils.ts", "../../@cfcs/core/src/reactive/const.ts", "../../@cfcs/core/src/reactive/detectDependencies.ts", "../../@cfcs/core/src/reactive/Observer.ts", "../../@cfcs/core/src/reactive/ComputedObserver.ts", "../../@cfcs/core/src/reactive/decorators/Observe.ts", "../../@cfcs/core/src/reactive/decorators/ReactiveSubscribe.ts", "../../@cfcs/core/src/reactive/inline.ts", "../../@cfcs/core/src/reactive/utils.ts", "../../@cfcs/core/src/reactive/adaptReactive.ts", "../../@cfcs/core/src/reactive/decorators/Computed.ts"],
  "sourcesContent": ["/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nexport const isUndefined = (value: any): value is undefined => typeof value === \"undefined\";\n", "import { DefaultProps } from \"./types\";\n\n// This class name is not matched to file name intentionally\n/**\n * Event class to provide additional properties\n * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스\n */\nclass ComponentEvent<PROPS extends Record<string, any>, TYPE extends string = string, THIS = any> implements DefaultProps<TYPE, THIS> {\n  /**\n   * A Component instance that triggered event.\n   * @type Component\n   * @ko 이벤트를 트리거한 Component 인스턴스.\n   * @example\n   * ```ts\n   * class ExtendedClass extends Component<{\n   *   someEvent: ComponentEvent<{ foo: number; bar: string }>\n   * }> {}\n   *\n   * new ExtendedClass().on(\"someEvent\", e => {\n   *   e.currentTarget; // ExtendedClass\n   * });\n   * ```\n   */\n  public currentTarget: THIS;\n\n  /**\n   * The name of the event.\n   * @type string\n   * @ko 이벤트 이름.\n   * @example\n   * ```ts\n   * class ExtendedClass extends Component<{\n   *   someEvent: ComponentEvent\n   * }> {}\n   *\n   * new ExtendedClass().on(\"someEvent\", e => {\n   *   e.eventType; // \"someEvent\"\n   * });\n   * ```\n   */\n  public eventType: TYPE;\n\n  private _canceled: boolean;\n\n  /**\n   * Create a new instance of ComponentEvent.\n   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.\n   * @param eventType The name of the event.<ko>이벤트 이름.</ko>\n   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>\n   */\n  public constructor(\n    eventType: TYPE,\n    props: PROPS\n  ) {\n    this._canceled = false;\n\n    if (props) {\n      for (const key of Object.keys(props as Record<string, any>)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this[key] = props[key];\n      }\n    }\n\n    this.eventType = eventType;\n  }\n\n  /**\n   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.\n   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.\n   */\n  public stop() {\n    this._canceled = true;\n  }\n\n  /**\n   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.\n   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.\n   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>\n   */\n  public isCanceled() {\n    return this._canceled;\n  }\n}\n\nexport default ComponentEvent;\n", "/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport { isUndefined } from \"./utils\";\nimport { EventCallback, EventHash, EventKey, EventMap, EventTriggerParams } from \"./types\";\nimport ComponentEvent from \"./ComponentEvent\";\nimport ActualComponentEvent from \"./ActualComponentEvent\";\n\n/**\n * A class used to manage events in a component\n * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스\n */\nclass Component<T extends EventMap> {\n  /**\n   * Version info string\n   * @ko 버전정보 문자열\n   * @name VERSION\n   * @static\n   * @example\n   * Component.VERSION;  // ex) 3.0.0\n   * @memberof Component\n   */\n  public static VERSION: string = \"#__VERSION__#\";\n\n  private _eventHandler: { [keys: string]: Array<(...args: any[]) => any> };\n\n  /**\n   * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n   */\n  public constructor() {\n    this._eventHandler = {};\n  }\n\n  public trigger<K extends EventKey<T>>(event: ComponentEvent<T[K], K, this> & T[K]): this;\n  public trigger<K extends EventKey<T>>(event: K, ...params: EventTriggerParams<T, K>): this;\n  /**\n   * Trigger a custom event.\n   * @ko 커스텀 이벤트를 발생시킨다\n   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>\n   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;\n   *   hi: { foo: { a: number; b: boolean } };\n   *   someEvent: (foo: number, bar: string) => void;\n   *   someOtherEvent: void; // When there's no event argument\n   * }> {\n   *   some(){\n   *     if(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n   *       this.trigger(\"hi\");// fire hi event.\n   *     }\n   *   }\n   * }\n   *\n   * const some = new Some();\n   * some.on(\"beforeHi\", e => {\n   *   if(condition){\n   *     e.stop(); // When event call to stop, `hi` event not call.\n   *   }\n   *   // `currentTarget` is component instance.\n   *   console.log(some === e.currentTarget); // true\n   *\n   *   typeof e.foo; // number\n   *   typeof e.bar; // string\n   * });\n   * some.on(\"hi\", e => {\n   *   typeof e.foo.b; // boolean\n   * });\n   * // If you want to more know event design. You can see article.\n   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n   * ```\n   */\n  public trigger<K extends EventKey<T>>(event: K | ComponentEvent<T[K], K, this>, ...params: EventTriggerParams<T, K> | void[]): this {\n    const eventName = (event as any) instanceof ActualComponentEvent\n      ? (event as ActualComponentEvent<T[K]>).eventType\n      : event as K;\n\n    const handlers = [...(this._eventHandler[eventName] || [])];\n\n    if (handlers.length <= 0) {\n      return this;\n    }\n\n    if ((event as any) instanceof ActualComponentEvent) {\n      (event as ActualComponentEvent<T[K]>).currentTarget = this;\n\n      handlers.forEach((handler: (event: ComponentEvent<T[K], K, this>) => any) => {\n        handler(event as ComponentEvent<T[K], K, this>);\n      });\n    } else {\n      handlers.forEach(handler => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        handler(...params);\n      });\n    }\n\n    return this;\n  }\n\n  public once<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;\n  public once(eventHash: EventHash<T, this>): this;\n  /**\n   * Executed event just one time.\n   * @ko 이벤트가 한번만 실행된다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: ComponentEvent;\n   * }> {\n   *   hi() {\n   *     alert(\"hi\");\n   *   }\n   *   thing() {\n   *     this.once(\"hi\", this.hi);\n   *   }\n   * }\n   *\n   * var some = new Some();\n   * some.thing();\n   * some.trigger(new ComponentEvent(\"hi\"));\n   * // fire alert(\"hi\");\n   * some.trigger(new ComponentEvent(\"hi\"));\n   * // Nothing happens\n   * ```\n   */\n  public once<K extends EventKey<T>>(eventName: K | EventHash<T, this>, handlerToAttach?: EventCallback<T, K, this>): this {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      const eventHash = eventName;\n\n      for (const key in eventHash) {\n        this.once((key as K), eventHash[key] as EventCallback<T, K, this>);\n      }\n      return this;\n    } else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n      const listener: any = (...args: any[]) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        handlerToAttach(...args);\n        this.off(eventName, listener);\n      };\n\n      this.on(eventName, listener);\n    }\n\n    return this;\n  }\n\n  /**\n   * Checks whether an event has been attached to a component.\n   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.\n   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>\n   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>\n   * @example\n   * ```ts\n   * import Component from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   some() {\n   *     this.hasOn(\"hi\");// check hi event.\n   *   }\n   * }\n   * ```\n   */\n  public hasOn<K extends EventKey<T>>(eventName: K): boolean {\n    return !!this._eventHandler[eventName];\n  }\n\n  public on<K extends EventKey<T>>(eventName: K, handlerToAttach: EventCallback<T, K, this>): this;\n  public on(eventHash: EventHash<T, this>): this;\n  /**\n   * Attaches an event to a component.\n   * @ko 컴포넌트에 이벤트를 등록한다.\n   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>\n   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.on(\"hi\",this.hi); //attach event\n   *   }\n   * }\n   * ```\n   */\n  public on<K extends EventKey<T>>(eventName: K | EventHash<T, this>, handlerToAttach?: EventCallback<T, K, this>): this {\n    if (typeof eventName === \"object\" && isUndefined(handlerToAttach)) {\n      const eventHash = eventName;\n\n      for (const name in eventHash) {\n        this.on(name, eventHash[name] as any);\n      }\n\n      return this;\n    } else if (typeof eventName === \"string\" &&\n      typeof handlerToAttach === \"function\") {\n      let handlerList = this._eventHandler[eventName];\n\n      if (isUndefined(handlerList)) {\n        this._eventHandler[eventName] = [];\n        handlerList = this._eventHandler[eventName];\n      }\n\n      handlerList.push(handlerToAttach as EventCallback<T, EventKey<T>, this>);\n    }\n\n    return this;\n  }\n\n  public off(eventHash?: EventHash<T, this>): this;\n  public off<K extends EventKey<T>>(eventName: K, handlerToDetach?: EventCallback<T, K, this>): this;\n  /**\n   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.\n   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.\n   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>\n   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>\n   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * import Component, { ComponentEvent } from \"@egjs/component\";\n   *\n   * class Some extends Component<{\n   *   hi: void;\n   * }> {\n   *   hi() {\n   *     console.log(\"hi\");\n   *   }\n   *   some() {\n   *     this.off(\"hi\",this.hi); //detach event\n   *   }\n   * }\n   * ```\n   */\n  public off<K extends EventKey<T>>(eventName?: K | EventHash<T, this>, handlerToDetach?: EventCallback<T, K, this>): this {\n    // Detach all event handlers.\n    if (isUndefined(eventName)) {\n      this._eventHandler = {};\n      return this;\n    }\n\n    // Detach all handlers for eventname or detach event handlers by object.\n    if (isUndefined(handlerToDetach)) {\n      if (typeof eventName === \"string\") {\n        delete this._eventHandler[eventName];\n        return this;\n      } else {\n        const eventHash = eventName;\n\n        for (const name in eventHash) {\n          this.off(name, eventHash[name] as any);\n        }\n        return this;\n      }\n    }\n\n    // Detach single event handler\n    const handlerList = this._eventHandler[eventName as K];\n\n    if (handlerList) {\n      let idx = 0;\n      for (const handlerFunction of handlerList) {\n        if (handlerFunction === handlerToDetach) {\n          handlerList.splice(idx, 1);\n\n          if (handlerList.length <= 0) {\n            delete this._eventHandler[eventName as K];\n          }\n\n          break;\n        }\n        idx++;\n      }\n    }\n\n    return this;\n  }\n}\n\nexport default Component;\n", "/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport ActualComponentEvent from \"./ActualComponentEvent\";\nimport { ComponentEventConstructor, DefaultProps } from \"./types\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-assignment\nconst ComponentEvent = ActualComponentEvent as ComponentEventConstructor;\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype ComponentEvent<PROPS = {}, TYPE extends string = string, THIS = any> = DefaultProps<TYPE, THIS> & PROPS;\n\nexport default ComponentEvent;\n", "/*\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\nimport Component from \"./Component\";\nimport ComponentEvent from \"./ComponentEvent\";\n\nexport { ComponentEvent };\nexport default Component;\n", "/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\n\n\n/**\n * @hidden\n */\nexport function keys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\n/**\n * @hidden\n */\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\n/**\n * @hidden\n */\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\n\n/**\n * @hidden\n */\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\n\n/**\n * @hidden\n */\nexport function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}\n", "import { isString, Ref } from \"../core\";\n\n/**\n * @hidden\n */\nexport function findTarget<Target extends Element = Element>(target: string | Target | Ref<Target> | null): Target | null {\n  let el!: Target;\n\n  if (!target) {\n    return null;\n  } if (isString(target)) {\n    el = document.querySelector<Target>(target)!;\n  } else if (target instanceof Element) {\n    el = target;\n  } else if (\"value\" in target || \"current\" in target) {\n    el = target.value! || target.current!;\n  }\n\n  return el;\n}\n\n/**\n * @description Sets the name of the class method to be exposed to the outside.\n * @category DOM\n * @return Property Decorator\n * @example\n * ```ts\n * import { withClassMethods } from \"@cfcs/core\";\n *\n * class YourFrameworkComponent {\n *   @withClassMethod(METHOD_NAMES)\n *   inst = new YourComponent();\n * }\n * ```\n */\nexport function withClassMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n", "export const OBSERVERS_PATH = \"__observers__\";\nexport const COMPUTED_PATH = \"__computed__\";\nexport const CFCS_DETECTED_DEPENDENCIES_VERSION = 1;\nexport const CFCS_DETECTED_DEPENDENCIES = \"__CFCS_DETECTED_DEPENDENCIES__\";\n", "import {\n  CFCS_DETECTED_DEPENDENCIES,\n  CFCS_DETECTED_DEPENDENCIES_VERSION,\n} from \"./const\";\nimport { Observer } from \"./Observer\";\n\nexport interface Detected {\n  host: Observer<any>;\n  observers: Array<Observer<any>>;\n  push(observer: Observer<any>): void;\n}\n\nexport function getDetectedStack(): Array<Detected> {\n  // Version issues do not occur when you access the native object in the global.\n  (Object as any)[CFCS_DETECTED_DEPENDENCIES] = (Object as any)[CFCS_DETECTED_DEPENDENCIES] || {};\n  const versionList = (Object as any)[CFCS_DETECTED_DEPENDENCIES];\n\n  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];\n\n  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];\n}\n\nexport function getCurrentDetected(): Detected | undefined {\n  const stack = getDetectedStack();\n\n  return stack[stack.length - 1];\n}\n\nexport function detectDependencies(host: Observer<any>) {\n  const stack = getDetectedStack();\n  const observers: Array<Observer> = [];\n  const detected: Detected = {\n    host,\n    observers,\n    push(observer: Observer<any>) {\n      if (host !== observer && observers.indexOf(observer) === -1) {\n        observers.push(observer);\n      }\n    },\n  };\n\n  stack.push(detected);\n  return detected;\n}\n\nexport function endDetectDependencies() {\n  const stack = getDetectedStack();\n\n  return stack.pop();\n}\n", "import Component from \"@egjs/component\";\nimport { getCurrentDetected } from \"./detectDependencies\";\n\ninterface EmitterEvents<Value> {\n  update: (value: Value, prevValue: Value) => void;\n}\n\n/**\n * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @see observe\n */\nexport class Observer<Value = any> {\n  protected _current: Value;\n  protected _emitter = new Component<EmitterEvents<Value>>();\n  /**\n   *\n   */\n  constructor(value?: Value) {\n    this._current = value as any;\n  }\n  /**\n   * return the current value.\n   */\n  public get current(): Value {\n    const currentDetected = getCurrentDetected();\n\n    currentDetected?.push(this);\n    return this._current as Value;\n  }\n  public set current(value: Value) {\n    this._setCurrent(value);\n  }\n  /**\n   * When the current value changes, the callback function is called.\n   */\n  public subscribe(callback: (value: Value, prevValue: Value) => void) {\n    this.current;\n    this._emitter.on(\"update\", callback);\n    return this;\n  }\n  /**\n   * Cancel the registered subscription through callback.\n   */\n  public unsubscribe(callback?: (value: Value, prevValue: Value) => void) {\n    this._emitter.off(\"update\", callback);\n    return this;\n  }\n  protected _setCurrent(value: Value) {\n    const prevValue = this._current;\n    const isUpdate = value !== prevValue;\n\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value, prevValue);\n    }\n  }\n  /**\n   * @hidden\n   */\n  public toString() {\n    return `${this.current}`;\n  }\n  /**\n   * @hidden\n   */\n  public valueOf() {\n    return this.current;\n  }\n}\n", "import { detectDependencies, endDetectDependencies } from \"./detectDependencies\";\nimport { Observer } from \"./Observer\";\n\n/**\n * @category Reactive\n * @hidden\n */\nexport class ComputedObserver<T> extends Observer<T> {\n  private _registered: Array<Observer<any>> = [];\n  /**\n   * @description Creates a new computed observer from the values of other observers.\n   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.\n   * @param _computedCallback A function for observers to be computed.\n   */\n  constructor(private _computedCallback: () => T) {\n    super();\n\n    this._current = this.current;\n  }\n\n  get current() {\n    detectDependencies(this);\n    const value = this._computedCallback();\n    const results = endDetectDependencies()!;\n\n    this._registered.forEach(observer => {\n      observer.unsubscribe(this._onCheckUpdate);\n    });\n    results.observers.forEach(observer => {\n      observer.subscribe(this._onCheckUpdate);\n    });\n    this._registered = results.observers;\n\n    return value;\n  }\n\n  private _onCheckUpdate = () => {\n    this._setCurrent(this.current);\n  }\n}\n", "import { getObserver } from \"../utils\";\n\n\nfunction injectObserve(prototype: any, memberName: string, publicName = memberName) {\n  const nextAttributes: PropertyDescriptor = {\n    configurable: true,\n    get: function () {\n      return getObserver(this, publicName).current;\n    },\n    set: function (value: any) {\n      getObserver(this, publicName, value).current = value;\n    },\n  };\n  Object.defineProperty(prototype, memberName, nextAttributes);\n  if (publicName !== memberName) {\n    Object.defineProperty(prototype, publicName, {\n      configurable: true,\n      get: function () {\n        return getObserver(this, publicName).current;\n      },\n    });\n  }\n}\n\nexport function Observe(protoype: any, memberName: string): void;\nexport function Observe(name?: string): (protoype: any, memberName: string) => void;\n/**\n * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n* ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  // The public name and state name are the same.\n  @Observe value1 = 1;\n  // If you want to set public name and private properties separately\n  @Observe(\"value2\") _value2 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\ninterface C\n```\n */\nexport function Observe(...args: any[]) {\n  if (args.length > 1) {\n    return injectObserve(args[0], args[1]);\n  }\n\n  return (prototype: any, memberName: string) => injectObserve(prototype, memberName, args[0]);\n}\n\n\nexport function Reactive(protoype: any, memberName: string): void;\nexport function Reactive(name?: string): (protoype: any, memberName: string) => void;\n/**\n * @hidden\n */\nexport function Reactive(...args: any[]) {\n  return Observe(...args);\n}\n\n", "import { keys } from \"../../core\";\nimport { getObserver, getObservers } from \"../utils\";\n\n/**\n * @hidden\n */\nexport function injectReactiveSubscribe(object: Record<string, any>,) {\n  object[\"subscribe\"] = function (name: string, callback: (value: any) => void) {\n    this[name];\n    getObserver(this, name).subscribe(callback);\n  };\n  object[\"unsubscribe\"] = function (name?: string, callback?: (value: any) => void) {\n    if (!name) {\n      keys(getObservers(this)).forEach((observerName) => {\n        this.unsubscribe(observerName);\n      });\n      return;\n    }\n    if (!(name in this)) {\n      return;\n    }\n    getObserver(this, name).unsubscribe(callback);\n  };\n}\n\n\n/**\n * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.\n * @category Reactive-Decorator\n * @see Observe\n * @example\n * ```ts\nimport { ReactiveSubscribe, Observe } from \"@cfcs/core\";\n\n@ReactiveSubscribe\nclass Component {\n  @Observe value1 = 1;\n\n  constructor() {\n    requestAnimationFrame(() => {\n      this.value1 = 2;\n    });\n  }\n}\n\ninterface Component extends ReactiveSubscribe<{\n  value1: number;\n  value2: number;\n}> {}\n\nconst component = new Component();\n\n// 1\nconsole.log(component.value1);\n\ncomponent.subscribe(\"value1\", nextValue => {\n  // When the change event occurs => (2, 2)\n  console.log(nextValue, component.value2);\n});\n```\n */\nexport function ReactiveSubscribe(Constructor: any) {\n  const prototype = Constructor.prototype;\n\n  injectReactiveSubscribe(prototype);\n}\n\n/**\n * `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.\n * @category Reactive\n */\nexport interface ReactiveSubscribe<State extends Record<string, any>> {\n  /**\n   * When the value of the property changes, the callback function is called.\n   */\n  subscribe<Name extends keyof State = keyof State>(\n    name: Name, callback: (value: State[Name]) => void): void;\n  /**\n   * Unregister the callback function corresponding to the property.\n   */\n  unsubscribe<Name extends keyof State = keyof State>(\n    name?: Name, callback?: (value: State[Name]) => void): void;\n}\n", "import { ComputedObserver } from \"./ComputedObserver\";\nimport { Observer } from \"./Observer\";\nimport { ExtractNever, isFunction, keys } from \"../core\";\nimport { Observe } from \"./decorators/Observe\";\nimport { injectReactiveSubscribe, ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { defineObservers, isObserver, setObserver } from \"./utils\";\n\n\ntype ConvertValue<Object extends Record<string, any>> = {\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];\n}\n\ntype PickObverser<Object extends Record<string, any>> = ExtractNever<{\n  [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;\n}>;\n\n/**\n * @typedef\n * @category Reactive\n */\nexport type ParitalReactiveObject<Object extends Record<string, any>>\n  = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;\n\n\n/**\n * Result type of `reactive` function call\n * @category Reactive\n * @see reactive\n * @example\n *  ```js\n * import { reactive } from \"@cfcs/core\";\n *\n * // define reactive state\n * const obj = reactive({\n *   value1: 1,\n *   value2: 2,\n * });\n * ```\n */\nexport type ReactiveObject<Object extends Record<string, any>>\n= Object & ReactiveSubscribe<Object>;\n\nfunction makeReactiveObject<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n  all?: boolean,\n): ParitalReactiveObject<Object> {\n  const result = isFunction(setup) ? setup() : setup;\n  const reactiveObject: Record<string, any> = {};\n\n  defineObservers(reactiveObject);\n  keys(result).forEach((name: any) => {\n    const value = result[name];\n\n    if (isObserver(value)) {\n      setObserver(reactiveObject, name, value);\n    } else {\n      setObserver(reactiveObject, name, observe(value));\n    }\n    Observe(name)(reactiveObject, name);\n  });\n\n  injectReactiveSubscribe(reactiveObject);\n  return reactiveObject as ParitalReactiveObject<Object>;\n}\n\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Makes all values into reactive objects.\n * @example\n * ```ts\n * import { reactive } from \"@cfcs/core\";\n *\n * const obj = reactive({\n *  value1: 1,\n *  value2: 2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * obj.value1 = 2;\n * ```\n */\nexport function reactive<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n): ReactiveObject<Object> {\n  return makeReactiveObject(setup, true) as ReactiveObject<Object>;\n}\n\n/**\n * @description Make the return value of the corresponding object or function a reactive object.\n * @category Reactive\n * @param setup - The target object or function to which reactive is applied\n * @returns Only the values to which observer is applied are objects to which reactive is applied.\n * @example\n * ```ts\n * import { partialReactive, observe } from \"@cfcs/core\";\n *\n * const value1 = observe(1);\n * const value2 = observe(2);\n * const obj = partialReactive({\n *  value1,\n *  value2,\n * });\n *\n * obj.subscribe(\"value1\", value1 => {\n *   console.log(value1);\n * });\n * value1.current = 2;\n * ```\n */\nexport function partialReactive<Object extends Record<string, any>>(\n  setup: Readonly<Object> | (() => Readonly<Object>),\n): ParitalReactiveObject<Object> {\n  return makeReactiveObject(setup);\n}\n\n/**\n * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.\n * @category Reactive\n * @example\n * ```ts\n * import { observe } from \"@cfcs/core\";\n *\n * const ob1 = observe(1);\n *\n * ob1.subscribe(nextValue => {\n *   console.log(nextValue);\n * });\n *\n * ob1.current = 2;\n * ```\n */\nexport function observe<Type>(defaultValue?: Type): Observer<Type> {\n  return new Observer<Type>(defaultValue);\n}\n\n/**\n * @hidden\n */\nexport function computed<Type>(computedCallback: () => Type) {\n  return new ComputedObserver(computedCallback);\n}\n", "import { COMPUTED_PATH, OBSERVERS_PATH } from \"./const\";\nimport { Observer } from \"./Observer\";\nimport { ReactiveMethods } from \"./types\";\nimport { isObject, Ref } from \"../core\";\nimport { observe } from \"./inline\";\nimport { ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\n\n/**\n * @hidden\n */\nexport function withReactiveMethods<\n  Instance,\n  Names extends keyof Partial<Instance>,\n  Return extends ReactiveMethods<Instance, Names>\n>(ref: Ref<Instance>, methods?: readonly Names[]): Return {\n  const obj: Record<any, any> = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(name => {\n    obj[name] = function (...args: any[]) {\n      const current: any = ref.current || ref.value;\n\n      return current[name](...args);\n    };\n  });\n  return obj as Return;\n}\n\n/**\n * @hidden\n */\nexport function defineObservers(instance: any) {\n  const observers: Record<string, Observer<any>> = {};\n\n  Object.defineProperty(instance, OBSERVERS_PATH, {\n    get() {\n      return observers;\n    },\n  });\n\n  return observers;\n}\n\n/**\n * @hidden\n */\nexport function getObservers(instance: any, isComputed?: boolean): Record<string, Observer<any>> {\n  if (!instance[OBSERVERS_PATH]) {\n    defineObservers(instance);\n  }\n  const observers = instance[OBSERVERS_PATH];\n\n  if (!isComputed) {\n    const computedList = instance?.constructor?.prototype?.[COMPUTED_PATH];\n\n    if (computedList) {\n      computedList.forEach(name => {\n        if (!(name in observers) && name in instance) {\n          instance[name];\n        }\n      });\n    }\n  }\n  return observers;\n}\n\n/**\n * @hidden\n */\nexport function getObserver(instance: any, name: string, defaultValue?: any): Observer<any> {\n  const observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\n\n/**\n * @hidden\n */\nexport function setObserver(instance: any, name: string, observer: Observer<any>) {\n  const observers = getObservers(instance);\n\n  observers[name] = observer;\n}\n\n/**\n * @description Whether that object is an observer instance\n * @category Reactive\n */\nexport function isObserver(val: any): val is Observer {\n  return val && isObject(val) && \"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n\n/**\n * @description Whether the object is reactive\n * @category Reactive\n */\nexport function isReactive(val: any): val is ReactiveSubscribe<any> {\n  return val && !isObserver(val) && \"subscribe\" in val && \"unsubscribe\" in val;\n}\n", "import { isFunction, keys } from \"../core\";\nimport { Ref } from \"../core/types\";\nimport { ReactiveAdapter, ReactiveAdapterParam } from \"./ReactiveAdapter\";\nimport { ReactiveSubscribe } from \"./decorators/ReactiveSubscribe\";\nimport { ReactiveEventCallback, ReactiveState } from \"./types\";\nimport { getObservers, withReactiveMethods } from \"./utils\";\nimport Component from \"@egjs/component\";\nimport { EventKey, EventTriggerParams } from \"@egjs/component/declaration/types\";\n\n/**\n * @category Reactive\n * @hidden\n */\nexport function adaptReactive<\n  Instance extends ReactiveSubscribe<Record<string, any>>,\n  State extends Record<string, any> = ReactiveState<Instance>,\n  Methods extends keyof Partial<Instance> = never,\n  Props = any,\n  Events extends Record<string, any> = {},\n>(adapter: ReactiveAdapterParam<Instance, State, Methods, Props, Events>, props?: () => Props) {\n  const objectAdapter: ReactiveAdapter<Instance, State, Methods, Props, Events> = isFunction(adapter) ? {\n    setup: adapter,\n  } : adapter;\n\n  function getProps(): Props {\n    return props?.() ?? objectAdapter.props?.() ?? objectAdapter.data?.() ?? {} as Props;\n  }\n\n  const eventEmitter = new Component<Events>();\n  const mountedHooks: Array<(props: Props, instance?: Instance | null) => Instance | void> = [];\n  const initHooks: Array<(instance: Instance, props: Props) => void> = [];\n  const destroyHooks: Array<(instance: Instance, props: Props) => void> = [];\n  const onHooks: Array<<EventName extends EventKey<Events>>(instance: Instance, eventName: EventName, listener: ReactiveEventCallback<Events, EventName>) => void | (() => void)> = [];\n  const instanceRef: Ref<Instance> = { current: null };\n  let offHooksList: Array<Array<() => void>> = [];\n  let initialState: State | null = null;\n  let eventNames: readonly (keyof Events)[] = [];\n  let methodNames: readonly Methods[] = [];\n\n\n  const onMounted = (callback: (props: Props, instance?: Instance | null) => Instance | void) => {\n    mountedHooks.push(callback);\n  };\n  const onInit = (callback: (instance: Instance, props: Props) => void) => {\n    initHooks.push(callback);\n  };\n  const onDestroy = (callback: (instance: Instance, props: Props) => void): void => {\n    destroyHooks.push(callback)\n  };\n  const on = (callback: <EventName extends EventKey<Events>>(instance: Instance, eventName: EventName, listener: ReactiveEventCallback<Events, EventName>) => void | (() => void)) => {\n    onHooks.push(callback);\n  };\n  const emit = <EventName extends EventKey<Events>>(eventName: EventName, ...params: EventTriggerParams<Events, EventName>) => {\n    eventEmitter.trigger(eventName, ...params);\n  };\n\n  const setInitialState = (state: State) => {\n    initialState = state;\n  };\n  const setEvents = (events: readonly (keyof Events)[]) => {\n    eventNames = events;\n  }\n  const setMethods = (methods: readonly Methods[]) => {\n    methodNames = methods;\n  }\n\n  if (objectAdapter.setup) {\n    instanceRef.current = objectAdapter.setup({\n      getProps,\n      setInitialState,\n      setEvents,\n      setMethods,\n      onMounted,\n      onDestroy,\n      onInit,\n      emit,\n      on,\n    }) || null;\n  }\n\n  if (objectAdapter.created) {\n    instanceRef.current = objectAdapter.created(getProps()) || null;\n  }\n\n  if (objectAdapter.events) {\n    setEvents(objectAdapter.events);\n  }\n  if (objectAdapter.state) {\n    setInitialState(objectAdapter.state);\n  }\n  if (objectAdapter.methods) {\n    setMethods(objectAdapter.methods);\n  }\n  if (objectAdapter.mounted) {\n    onMounted(objectAdapter.mounted);\n  }\n  if (objectAdapter.destroy) {\n    destroyHooks.push(objectAdapter.destroy);\n  }\n  if (objectAdapter.init) {\n    initHooks.push(objectAdapter.init);\n  }\n  if (objectAdapter.on) {\n    onHooks.push((instance, eventName, listener) => {\n      const off = objectAdapter.on!(instance, eventName, listener);\n\n      return () => {\n        off && off();\n        objectAdapter.off?.(instance, eventName, listener);\n      };\n    });\n  }\n\n  return {\n    events: () => eventNames,\n    state(): State {\n      const inst = instanceRef.current;\n\n      if (initialState) {\n        return initialState;\n      }\n      if (inst) {\n        const observers = getObservers(inst);\n\n        setInitialState(keys(observers).reduce((prev, cur) => {\n          prev[cur] = observers[cur].current;\n          return prev;\n        }, {} as any));\n      }\n      return initialState || {} as State;\n    },\n    instance() {\n      return instanceRef.current;\n    },\n    mounted(): void {\n      const props = getProps();\n\n      mountedHooks.forEach(hook => {\n        instanceRef.current = hook(props, instanceRef.current) || instanceRef.current;\n      });\n\n    },\n    init(): void {\n      // on events\n      const instance = instanceRef.current!;\n      const props = getProps();\n\n      offHooksList = (eventNames as string[]).map(eventName => {\n        const listener = (...params: any[]) => {\n          (eventEmitter as any).trigger(eventName, ...params);\n        };\n\n        const instance = instanceRef.current!;\n\n        return onHooks.map(hook => hook(instance, eventName, listener as any)).filter(Boolean) as Array<() => void>;\n      });\n\n      // init\n      initHooks.forEach(hook => {\n        hook(instance, props);\n      });\n    },\n    destroy(): void {\n      // off events\n      offHooksList.forEach(offHooks => {\n        offHooks.forEach(hook => {\n          hook();\n        });\n      });\n\n      // destroy\n      eventEmitter.off();\n      const instance = instanceRef.current!;\n      const props = getProps();\n\n      destroyHooks.forEach(hook => {\n        hook(instance, props);\n      });\n    },\n    methods() {\n      return withReactiveMethods<any, any, any>(instanceRef, methodNames);\n    },\n    on(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      eventEmitter.on(eventName, listener);\n    },\n    off(eventName: string, listener: ReactiveEventCallback<any, any>) {\n      eventEmitter.off(eventName, listener);\n    },\n  };\n}\n", "import { COMPUTED_PATH } from \"../const\";\nimport { computed } from \"../inline\";\nimport { getObserver, getObservers } from \"../utils\";\n\n\n/**\n * @description `Computed` is a property decorator.\n * Changes in computed state values are also recognized according to changes in observers used within the getter function.\n * You can detect its status through `.subscribe`.\n * @hidden\n * @category Reactive-Decorator\n * @see ReactiveSubscribe\n * @example\n * ```ts\nconst ob1 = observe(0);\nconst ob2 = observe(1);\n\n// When\n@ReactiveSubscribe\nclass TestComputed {\n  @Computed\n  get ob3() {\n    return ob1.current + ob2.current;\n  }\n}\nconst inst = new TestComputed();\n\ninst.subscribe(\"ob3\", ob3 => {\n  console.log(ob3);\n});\n\nob1.current = 1;\n```\n */\nexport function Computed(prototype: any, memberName: string, attributes: PropertyDescriptor): PropertyDescriptor {\n  const get = attributes.get!;\n\n  function getComputed() {\n    const observers = getObservers(this, true);\n\n    if (!(memberName in observers)) {\n      observers[memberName] = computed(get.bind(this));\n    }\n    return getObserver(this, memberName).current;\n  }\n  const nextAttributes: PropertyDescriptor = {\n    configurable: true,\n    get: getComputed,\n  }\n\n  prototype[COMPUTED_PATH] ||= [];\n  const computedList = prototype[COMPUTED_PATH];\n\n  if (computedList.indexOf(memberName) === -1) {\n    computedList.push(memberName);\n  }\n  Object.defineProperty(prototype, memberName, nextAttributes);\n\n  return nextAttributes;\n}\n"],
  "mappings": "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",
  "names": ["isUndefined", "value", "ComponentEvent", "eventType", "props", "_canceled", "_b", "__values", "Object", "keys", "key", "Component", "_eventHandler", "event", "_i", "params", "eventName", "ActualComponentEvent", "handlers", "length", "currentTarget", "forEach", "handler", "handlerToAttach", "eventHash", "once", "listener_1", "args", "_this", "off", "on", "name", "handlerList", "push", "handlerToDetach", "idx", "handlerList_1", "handlerFunction", "splice", "keys", "obj", "Object", "camelize", "str", "replace", "all", "letter", "toUpperCase", "isString", "val", "isObject", "isFunction", "findTarget", "target", "el", "document", "querySelector", "Element", "value", "current", "withClassMethods", "methods", "prototype", "memberName", "forEach", "name", "args", "_i", "arguments", "length", "result", "_a", "apply", "OBSERVERS_PATH", "COMPUTED_PATH", "CFCS_DETECTED_DEPENDENCIES_VERSION", "CFCS_DETECTED_DEPENDENCIES", "getDetectedStack", "versionList", "getCurrentDetected", "stack", "detectDependencies", "host", "observers", "detected", "push", "observer", "indexOf", "endDetectDependencies", "pop", "Observer", "_emitter", "Component", "_current", "defineProperty", "get", "currentDetected", "set", "_setCurrent", "subscribe", "callback", "on", "unsubscribe", "off", "prevValue", "isUpdate", "trigger", "toString", "concat", "valueOf", "ComputedObserver", "_super", "__extends", "_computedCallback", "_this", "_registered", "_onCheckUpdate", "results", "injectObserve", "publicName", "nextAttributes", "configurable", "getObserver", "Observe", "Reactive", "injectReactiveSubscribe", "object", "getObservers", "observerName", "ReactiveSubscribe", "Constructor", "makeReactiveObject", "setup", "reactiveObject", "defineObservers", "isObserver", "setObserver", "observe", "reactive", "partialReactive", "defaultValue", "computed", "computedCallback", "withReactiveMethods", "ref", "instance", "isComputed", "computedList", "_b", "constructor", "isReactive", "adaptReactive", "adapter", "props", "objectAdapter", "getProps", "_e", "call", "_c", "_d", "data", "eventEmitter", "mountedHooks", "initHooks", "destroyHooks", "onHooks", "instanceRef", "offHooksList", "initialState", "eventNames", "methodNames", "onMounted", "onInit", "onDestroy", "emit", "eventName", "params", "setInitialState", "state", "setEvents", "events", "setMethods", "created", "mounted", "destroy", "init", "listener", "inst", "observers_1", "reduce", "prev", "cur", "hook", "map", "__spreadArray", "filter", "Boolean", "offHooks", "Computed", "attributes", "getComputed", "bind"]
}
