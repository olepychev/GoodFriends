import {
  ComponentEvent$1,
  Reactive,
  ReactiveSubscribe,
  component_esm_default
} from "./chunk-5XSFEMF4.js";

// node_modules/@egjs/agent/dist/agent.esm.js
function some(arr, callback) {
  var length = arr.length;
  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }
  return false;
}
function find(arr, callback) {
  var length = arr.length;
  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }
  return null;
}
function getUserAgentString(agent2) {
  var userAgent = agent2;
  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }
    userAgent = navigator.userAgent || "";
  }
  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }
  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function(preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);
    if (!result || preset.brand) {
      return false;
    }
    userPreset = preset;
    version = result[3] || "-1";
    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }
    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function(preset) {
    var result = findBrand(brands, preset);
    if (!result) {
      return false;
    }
    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function(_a2) {
    var brand = _a2.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}];
var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function isWebView(userAgent) {
  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;
}
function getLegacyAgent(userAgent) {
  var nextAgent = getUserAgentString(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(nextAgent),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  var _a2 = findPreset(BROWSER_PRESETS, nextAgent), browserPreset = _a2.preset, browserVersion = _a2.version;
  var _b2 = findPreset(OS_PRESETS, nextAgent), osPreset = _b2.preset, osVersion = _b2.version;
  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;
  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }
  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }
  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion;
    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser,
    os,
    isMobile,
    isHints: false
  };
}
function getClientHintsAgent(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var fullVersionList = osData && osData.fullVersionList;
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function(preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;
  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }
  var platfomResult = find(OS_PRESETS, function(preset) {
    return new RegExp("" + preset.test, "g").exec(platform);
  });
  os.name = platfomResult ? platfomResult.id : "";
  if (osData) {
    os.version = osData.platformVersion;
  }
  if (fullVersionList && fullVersionList.length) {
    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);
    browser.name = browserBrandByFullVersionList.brand || browser.name;
    browser.version = browserBrandByFullVersionList.version || browser.version;
  } else {
    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
    browser.name = browserBrand.brand || browser.name;
    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;
  }
  if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }
  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }
  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser,
    os,
    isMobile,
    isHints: true
  };
}
function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return getClientHintsAgent();
  } else {
    return getLegacyAgent(userAgent);
  }
}
var agent_esm_default = agent;

// node_modules/@egjs/axes/node_modules/@cfcs/core/dist/cfcs.esm.js
function keys(obj) {
  return Object.keys(obj);
}
var OBSERVERS_PATH = "__observers__";
var Observer = function() {
  function Observer2(value) {
    this._emitter = new component_esm_default();
    this._current = value;
  }
  var __proto = Observer2.prototype;
  Object.defineProperty(__proto, "current", {
    get: function() {
      return this._current;
    },
    set: function(value) {
      var isUpdate = value !== this._current;
      this._current = value;
      if (isUpdate) {
        this._emitter.trigger("update", value);
      }
    },
    enumerable: false,
    configurable: true
  });
  __proto.subscribe = function(callback) {
    this._emitter.on("update", callback);
  };
  __proto.unsubscribe = function(callback) {
    this._emitter.off("update", callback);
  };
  return Observer2;
}();
function observe(defaultValue) {
  return new Observer(defaultValue);
}
function getObservers(instance) {
  if (!instance[OBSERVERS_PATH]) {
    instance[OBSERVERS_PATH] = {};
  }
  return instance[OBSERVERS_PATH];
}
function getObserver(instance, name, defaultValue) {
  var observers = getObservers(instance);
  if (!observers[name]) {
    observers[name] = observe(defaultValue);
  }
  return observers[name];
}
function injectReactiveSubscribe(object) {
  object["subscribe"] = function(name, callback) {
    getObserver(this, name).subscribe(callback);
  };
  object["unsubscribe"] = function(name, callback) {
    var _this = this;
    if (!name) {
      keys(getObservers(this)).forEach(function(observerName) {
        _this.unsubscribe(observerName);
      });
      return;
    }
    if (!(name in this)) {
      return;
    }
    getObserver(this, name).unsubscribe(callback);
  };
}
function ReactiveSubscribe2(Constructor) {
  var prototype = Constructor.prototype;
  injectReactiveSubscribe(prototype);
}

// node_modules/@egjs/axes/dist/axes.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var win;
if (typeof window === "undefined") {
  win = {
    navigator: {
      userAgent: ""
    }
  };
} else {
  win = window;
}
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_HORIZONTAL = 2 | 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_VERTICAL = 8 | 16;
var DIRECTION_ALL = 2 | 4 | 8 | 16;
var MOUSE_LEFT = "left";
var MOUSE_RIGHT = "right";
var MOUSE_MIDDLE = "middle";
var ANY = "any";
var NONE = "none";
var SHIFT = "shift";
var CTRL = "ctrl";
var ALT = "alt";
var META = "meta";
var VELOCITY_INTERVAL = 16;
var IOS_EDGE_THRESHOLD = 30;
var IS_IOS_SAFARI = "ontouchstart" in win && agent_esm_default().browser.name === "safari";
var TRANSFORM = function() {
  if (typeof document === "undefined") {
    return "";
  }
  var bodyStyle = (document.head || document.getElementsByTagName("head")[0]).style;
  var target = ["transform", "webkitTransform", "msTransform", "mozTransform"];
  for (var i = 0, len = target.length; i < len; i++) {
    if (target[i] in bodyStyle) {
      return target[i];
    }
  }
  return "";
}();
var PREVENT_DRAG_CSSPROPS = {
  "-webkit-user-select": "none",
  "-ms-user-select": "none",
  "-moz-user-select": "none",
  "user-select": "none",
  "-webkit-user-drag": "none"
};
var toArray = function(nodes) {
  var el = [];
  for (var i = 0, len = nodes.length; i < len; i++) {
    el.push(nodes[i]);
  }
  return el;
};
var $ = function(param, multi) {
  if (multi === void 0) {
    multi = false;
  }
  var el;
  if (typeof param === "string") {
    var match = param.match(/^<([a-z]+)\s*([^>]*)>/);
    if (match) {
      var dummy = document.createElement("div");
      dummy.innerHTML = param;
      el = toArray(dummy.childNodes);
    } else {
      el = toArray(document.querySelectorAll(param));
    }
    if (!multi) {
      el = el.length >= 1 ? el[0] : void 0;
    }
  } else if (param === win) {
    el = param;
  } else if ("value" in param || "current" in param) {
    el = param.value || param.current;
  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {
    el = param;
  } else if ("jQuery" in win && param instanceof jQuery || param.constructor.prototype.jquery) {
    el = multi ? param.toArray() : param.get(0);
  } else if (Array.isArray(param)) {
    el = param.map(function(v) {
      return $(v);
    });
    if (!multi) {
      el = el.length >= 1 ? el[0] : void 0;
    }
  }
  return el;
};
var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame;
var caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame;
if (raf && !caf) {
  keyInfo_1 = {};
  oldraf_1 = raf;
  raf = function(callback) {
    var wrapCallback = function(timestamp) {
      if (keyInfo_1[key]) {
        callback(timestamp);
      }
    };
    var key = oldraf_1(wrapCallback);
    keyInfo_1[key] = true;
    return key;
  };
  caf = function(key) {
    delete keyInfo_1[key];
  };
} else if (!(raf && caf)) {
  raf = function(callback) {
    return win.setTimeout(function() {
      callback(win.performance && win.performance.now && win.performance.now() || (/* @__PURE__ */ new Date()).getTime());
    }, 16);
  };
  caf = win.clearTimeout;
}
var keyInfo_1;
var oldraf_1;
var requestAnimationFrame = function(fp) {
  return raf(fp);
};
var cancelAnimationFrame = function(key) {
  caf(key);
};
var map = function(obj, callback) {
  var tranformed = {};
  for (var k in obj) {
    if (k) {
      tranformed[k] = callback(obj[k], k);
    }
  }
  return tranformed;
};
var filter = function(obj, callback) {
  var filtered = {};
  for (var k in obj) {
    if (k && callback(obj[k], k)) {
      filtered[k] = obj[k];
    }
  }
  return filtered;
};
var every = function(obj, callback) {
  for (var k in obj) {
    if (k && !callback(obj[k], k)) {
      return false;
    }
  }
  return true;
};
var equal = function(target, base) {
  return every(target, function(v, k) {
    return v === base[k];
  });
};
var roundNumFunc = {};
var roundNumber = function(num, roundUnit) {
  if (!roundNumFunc[roundUnit]) {
    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);
  }
  return roundNumFunc[roundUnit](num);
};
var roundNumbers = function(num, roundUnit) {
  if (!num || !roundUnit) {
    return num;
  }
  return map(num, function(value, key) {
    return roundNumber(value, typeof roundUnit === "number" ? roundUnit : roundUnit[key]);
  });
};
var getDecimalPlace = function(val) {
  if (!isFinite(val)) {
    return 0;
  }
  var v = "".concat(val);
  if (v.indexOf("e") >= 0) {
    var p = 0;
    var e = 1;
    while (Math.round(val * e) / e !== val) {
      e *= 10;
      p++;
    }
    return p;
  }
  return v.indexOf(".") >= 0 ? v.length - v.indexOf(".") - 1 : 0;
};
var inversePow = function(n) {
  return 1 / Math.pow(10, n);
};
var getRoundFunc = function(v) {
  var p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;
  return function(n) {
    if (v === 0) {
      return 0;
    }
    return Math.round(Math.round(n / v) * v * p) / p;
  };
};
var getAngle = function(posX, posY) {
  return Math.atan2(posY, posX) * 180 / Math.PI;
};
var isCssPropsFromAxes = function(originalCssProps) {
  var same = true;
  Object.keys(PREVENT_DRAG_CSSPROPS).forEach(function(prop) {
    if (!originalCssProps || originalCssProps[prop] !== PREVENT_DRAG_CSSPROPS[prop]) {
      same = false;
    }
  });
  return same;
};
var getDirection = function(useHorizontal, useVertical) {
  if (useHorizontal && useVertical) {
    return DIRECTION_ALL;
  } else if (useHorizontal) {
    return DIRECTION_HORIZONTAL;
  } else if (useVertical) {
    return DIRECTION_VERTICAL;
  } else {
    return DIRECTION_NONE;
  }
};
var useDirection = function(checkType, direction, userDirection) {
  if (userDirection) {
    return !!(direction === DIRECTION_ALL || direction & checkType && userDirection & checkType);
  } else {
    return !!(direction & checkType);
  }
};
var setCssProps = function(element, option, direction) {
  var _a2;
  var touchActionMap = (_a2 = {}, _a2[DIRECTION_NONE] = "auto", _a2[DIRECTION_ALL] = "none", _a2[DIRECTION_VERTICAL] = "pan-x", _a2[DIRECTION_HORIZONTAL] = "pan-y", _a2);
  var oldCssProps = {};
  if (element && element.style) {
    var touchAction = option.touchAction ? option.touchAction : touchActionMap[direction];
    var newCssProps_1 = __assign(__assign({}, PREVENT_DRAG_CSSPROPS), {
      "touch-action": element.style["touch-action"] === "none" ? "none" : touchAction
    });
    Object.keys(newCssProps_1).forEach(function(prop) {
      oldCssProps[prop] = element.style[prop];
      element.style[prop] = newCssProps_1[prop];
    });
  }
  return oldCssProps;
};
var revertCssProps = function(element, originalCssProps) {
  if (element && element.style && originalCssProps) {
    Object.keys(originalCssProps).forEach(function(prop) {
      element.style[prop] = originalCssProps[prop];
    });
  }
  return;
};
var EventManager = function() {
  function EventManager2(_axes) {
    this._axes = _axes;
  }
  var __proto = EventManager2.prototype;
  __proto.hold = function(pos, option) {
    var roundPos = this._getRoundPos(pos).roundPos;
    this._axes.trigger(new ComponentEvent$1("hold", {
      pos: roundPos,
      input: option.input || null,
      inputEvent: option.event || null,
      isTrusted: true
    }));
  };
  __proto.triggerRelease = function(param) {
    var _a2 = this._getRoundPos(param.destPos, param.depaPos), roundPos = _a2.roundPos, roundDepa = _a2.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    this._axes.trigger(new ComponentEvent$1("release", __assign(__assign({}, param), {
      bounceRatio: this._getBounceRatio(roundPos)
    })));
  };
  __proto.triggerChange = function(pos, depaPos, option, holding) {
    var _this = this;
    if (holding === void 0) {
      holding = false;
    }
    var animationManager = this.animationManager;
    var axisManager = animationManager.axisManager;
    var eventInfo = animationManager.getEventInfo();
    var _a2 = this._getRoundPos(pos, depaPos), roundPos = _a2.roundPos, roundDepa = _a2.roundDepa;
    var moveTo = axisManager.moveTo(roundPos, roundDepa);
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.event) || null;
    var param = {
      pos: moveTo.pos,
      delta: moveTo.delta,
      bounceRatio: this._getBounceRatio(moveTo.pos),
      holding,
      inputEvent,
      isTrusted: !!inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.input) || null,
      set: inputEvent ? this._createUserControll(moveTo.pos) : function() {
      }
      // eslint-disable-line @typescript-eslint/no-empty-function
    };
    var event = new ComponentEvent$1("change", param);
    this._axes.trigger(event);
    Object.keys(moveTo.pos).forEach(function(axis) {
      var p = moveTo.pos[axis];
      getObserver(_this._axes, axis, p).current = p;
    });
    if (inputEvent) {
      axisManager.set(param.set().destPos);
    }
    return !event.isCanceled();
  };
  __proto.triggerAnimationStart = function(param) {
    var _a2 = this._getRoundPos(param.destPos, param.depaPos), roundPos = _a2.roundPos, roundDepa = _a2.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    var event = new ComponentEvent$1("animationStart", param);
    this._axes.trigger(event);
    return !event.isCanceled();
  };
  __proto.triggerAnimationEnd = function(isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("animationEnd", {
      isTrusted
    }));
  };
  __proto.triggerFinish = function(isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("finish", {
      isTrusted
    }));
  };
  __proto.setAnimationManager = function(animationManager) {
    this.animationManager = animationManager;
  };
  __proto.destroy = function() {
    this._axes.off();
  };
  __proto._createUserControll = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    var userControl = {
      destPos: __assign({}, pos),
      duration
    };
    return function(toPos, userDuration) {
      if (toPos) {
        userControl.destPos = __assign({}, toPos);
      }
      if (userDuration !== void 0) {
        userControl.duration = userDuration;
      }
      return userControl;
    };
  };
  __proto._getRoundPos = function(pos, depaPos) {
    var roundUnit = this._axes.options.round;
    return {
      roundPos: roundNumbers(pos, roundUnit),
      roundDepa: roundNumbers(depaPos, roundUnit)
    };
  };
  __proto._getBounceRatio = function(pos) {
    return this._axes.axisManager.map(pos, function(v, opt) {
      if (v < opt.range[0] && opt.bounce[0] !== 0) {
        return (opt.range[0] - v) / opt.bounce[0];
      } else if (v > opt.range[1] && opt.bounce[1] !== 0) {
        return (v - opt.range[1]) / opt.bounce[1];
      } else {
        return 0;
      }
    });
  };
  return EventManager2;
}();
var InterruptManager = function() {
  function InterruptManager2(_options) {
    this._options = _options;
    this._prevented = false;
  }
  var __proto = InterruptManager2.prototype;
  __proto.isInterrupting = function() {
    return this._options.interruptable || this._prevented;
  };
  __proto.isInterrupted = function() {
    return !this._options.interruptable && this._prevented;
  };
  __proto.setInterrupt = function(prevented) {
    if (!this._options.interruptable) {
      this._prevented = prevented;
    }
  };
  return InterruptManager2;
}();
var getInsidePosition = function(destPos, range, circular, bounce) {
  var toDestPos = destPos;
  var targetRange = [circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0], circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1]];
  toDestPos = Math.max(targetRange[0], toDestPos);
  toDestPos = Math.min(targetRange[1], toDestPos);
  return toDestPos;
};
var isOutside = function(pos, range) {
  return pos < range[0] || pos > range[1];
};
var isEndofBounce = function(pos, range, bounce, circular) {
  return !circular[0] && pos === range[0] - bounce[0] || !circular[1] && pos === range[1] + bounce[1];
};
var getDuration = function(distance, deceleration) {
  var duration = Math.sqrt(distance / deceleration * 2);
  return duration < 100 ? 0 : duration;
};
var isCircularable = function(destPos, range, circular) {
  return circular[1] && destPos > range[1] || circular[0] && destPos < range[0];
};
var getCirculatedPos = function(pos, range, circular) {
  var toPos = pos;
  var min = range[0];
  var max = range[1];
  var length = max - min;
  if (circular[1] && pos > max) {
    toPos = (toPos - max) % length + min;
  }
  if (circular[0] && pos < min) {
    toPos = (toPos - min) % length + max;
  }
  return toPos;
};
var AxisManager = function() {
  function AxisManager2(_axis) {
    var _this = this;
    this._axis = _axis;
    this._complementOptions();
    this._pos = Object.keys(this._axis).reduce(function(pos, v) {
      pos[v] = _this._axis[v].startPos;
      return pos;
    }, {});
  }
  var __proto = AxisManager2.prototype;
  __proto.getDelta = function(depaPos, destPos) {
    var fullDepaPos = this.get(depaPos);
    return map(this.get(destPos), function(v, k) {
      return v - fullDepaPos[k];
    });
  };
  __proto.get = function(axes) {
    var _this = this;
    if (axes && Array.isArray(axes)) {
      return axes.reduce(function(acc, v) {
        if (v && v in _this._pos) {
          acc[v] = _this._pos[v];
        }
        return acc;
      }, {});
    } else {
      return __assign(__assign({}, this._pos), axes || {});
    }
  };
  __proto.moveTo = function(pos, depaPos) {
    if (depaPos === void 0) {
      depaPos = this._pos;
    }
    var delta = map(this._pos, function(v, key) {
      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;
    });
    this.set(this.map(pos, function(v, opt) {
      return opt ? getCirculatedPos(v, opt.range, opt.circular) : 0;
    }));
    return {
      pos: __assign({}, this._pos),
      delta
    };
  };
  __proto.set = function(pos) {
    for (var k in pos) {
      if (k && k in this._pos) {
        this._pos[k] = pos[k];
      }
    }
  };
  __proto.every = function(pos, callback) {
    var axisOptions = this._axis;
    return every(pos, function(value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.filter = function(pos, callback) {
    var axisOptions = this._axis;
    return filter(pos, function(value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.map = function(pos, callback) {
    var axisOptions = this._axis;
    return map(pos, function(value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.isOutside = function(axes) {
    return !this.every(axes ? this.get(axes) : this._pos, function(v, opt) {
      return !isOutside(v, opt.range);
    });
  };
  __proto.getAxisOptions = function(key) {
    return this._axis[key];
  };
  __proto.setAxis = function(axis) {
    var _this = this;
    Object.keys(axis).forEach(function(key) {
      if (!_this._axis[key]) {
        throw new Error("Axis ".concat(key, " does not exist in Axes instance"));
      }
      _this._axis[key] = __assign(__assign({}, _this._axis[key]), axis[key]);
    });
    this._complementOptions();
  };
  __proto._complementOptions = function() {
    var _this = this;
    Object.keys(this._axis).forEach(function(axis) {
      _this._axis[axis] = __assign({
        range: [0, 100],
        startPos: _this._axis[axis].range[0],
        bounce: [0, 0],
        circular: [false, false]
      }, _this._axis[axis]);
      ["bounce", "circular"].forEach(function(v) {
        var axisOption = _this._axis;
        var key = axisOption[axis][v];
        if (/string|number|boolean/.test(typeof key)) {
          axisOption[axis][v] = [key, key];
        }
      });
    });
  };
  return AxisManager2;
}();
var SUPPORT_TOUCH = "ontouchstart" in win;
var SUPPORT_POINTER = "PointerEvent" in win;
var SUPPORT_MSPOINTER = "MSPointerEvent" in win;
var SUPPORT_POINTER_EVENTS = SUPPORT_POINTER || SUPPORT_MSPOINTER;
var isValidKey = function(event, inputKey) {
  if (!inputKey || inputKey.indexOf(ANY) > -1 || inputKey.indexOf(NONE) > -1 && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey || inputKey.indexOf(SHIFT) > -1 && event.shiftKey || inputKey.indexOf(CTRL) > -1 && event.ctrlKey || inputKey.indexOf(ALT) > -1 && event.altKey || inputKey.indexOf(META) > -1 && event.metaKey) {
    return true;
  }
  return false;
};
var EventInput = function() {
  function EventInput2() {
    var _this = this;
    this._stopContextMenu = function(event) {
      event.preventDefault();
      win.removeEventListener("contextmenu", _this._stopContextMenu);
    };
  }
  var __proto = EventInput2.prototype;
  __proto.extendEvent = function(event) {
    var _a2;
    var prevEvent = this.prevEvent;
    var center = this._getCenter(event);
    var movement = prevEvent ? this._getMovement(event) : {
      x: 0,
      y: 0
    };
    var scale = prevEvent ? this._getScale(event) : 1;
    var angle = prevEvent ? getAngle(center.x - prevEvent.center.x, center.y - prevEvent.center.y) : 0;
    var deltaX = prevEvent ? prevEvent.deltaX + movement.x : movement.x;
    var deltaY = prevEvent ? prevEvent.deltaY + movement.y : movement.y;
    var offsetX = movement.x;
    var offsetY = movement.y;
    var latestInterval = this._latestInterval;
    var timeStamp = Date.now();
    var deltaTime = latestInterval ? timeStamp - latestInterval.timestamp : 0;
    var velocityX = prevEvent ? prevEvent.velocityX : 0;
    var velocityY = prevEvent ? prevEvent.velocityY : 0;
    if (!latestInterval || deltaTime >= VELOCITY_INTERVAL) {
      if (latestInterval) {
        _a2 = [(deltaX - latestInterval.deltaX) / deltaTime, (deltaY - latestInterval.deltaY) / deltaTime], velocityX = _a2[0], velocityY = _a2[1];
      }
      this._latestInterval = {
        timestamp: timeStamp,
        deltaX,
        deltaY
      };
    }
    return {
      srcEvent: event,
      scale,
      angle,
      center,
      deltaX,
      deltaY,
      offsetX,
      offsetY,
      velocityX,
      velocityY,
      preventSystemEvent: true
    };
  };
  __proto._getDistance = function(start, end) {
    var x = end.clientX - start.clientX;
    var y = end.clientY - start.clientY;
    return Math.sqrt(x * x + y * y);
  };
  __proto._getButton = function(event) {
    var buttonCodeMap = {
      1: MOUSE_LEFT,
      2: MOUSE_RIGHT,
      4: MOUSE_MIDDLE
    };
    var button = this._isTouchEvent(event) ? MOUSE_LEFT : buttonCodeMap[event.buttons];
    return button ? button : null;
  };
  __proto._isTouchEvent = function(event) {
    return event.type && event.type.indexOf("touch") > -1;
  };
  __proto._isValidButton = function(button, inputButton) {
    return inputButton.indexOf(button) > -1;
  };
  __proto._isValidEvent = function(event, inputKey, inputButton) {
    return (!inputKey || isValidKey(event, inputKey)) && (!inputButton || this._isValidButton(this._getButton(event), inputButton));
  };
  __proto._preventMouseButton = function(event, button) {
    if (button === MOUSE_RIGHT) {
      win.addEventListener("contextmenu", this._stopContextMenu);
    } else if (button === MOUSE_MIDDLE) {
      event.preventDefault();
    }
  };
  return EventInput2;
}();
var MouseEventInput = function(_super) {
  __extends(MouseEventInput2, _super);
  function MouseEventInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown"];
    _this.move = ["mousemove"];
    _this.end = ["mouseup"];
    return _this;
  }
  var __proto = MouseEventInput2.prototype;
  __proto.onEventStart = function(event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function(event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function() {
    return;
  };
  __proto.onRelease = function() {
    this.prevEvent = null;
    return;
  };
  __proto.getTouches = function(event, inputButton) {
    if (inputButton) {
      var buttonCodeMap = {
        1: MOUSE_LEFT,
        2: MOUSE_MIDDLE,
        3: MOUSE_RIGHT
      };
      return this._isValidButton(buttonCodeMap[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
    return 0;
  };
  __proto._getScale = function() {
    return 1;
  };
  __proto._getCenter = function(event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function(event) {
    var prev = this.prevEvent.srcEvent;
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  return MouseEventInput2;
}(EventInput);
var TouchEventInput = function(_super) {
  __extends(TouchEventInput2, _super);
  function TouchEventInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["touchstart"];
    _this.move = ["touchmove"];
    _this.end = ["touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchEventInput2.prototype;
  __proto.onEventStart = function(event, inputKey) {
    this._baseTouches = event.touches;
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventMove = function(event, inputKey) {
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function(event) {
    this._baseTouches = event.touches;
    return;
  };
  __proto.onRelease = function() {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function(event) {
    return event.touches.length;
  };
  __proto._getScale = function(event) {
    if (event.touches.length !== 2 || this._baseTouches.length < 2) {
      return null;
    }
    return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
  };
  __proto._getCenter = function(event) {
    return {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
  };
  __proto._getMovement = function(event) {
    var prev = this.prevEvent.srcEvent;
    if (event.touches[0].identifier !== prev.touches[0].identifier) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.touches[0].clientX - prev.touches[0].clientX,
      y: event.touches[0].clientY - prev.touches[0].clientY
    };
  };
  return TouchEventInput2;
}(EventInput);
var PointerEventInput = function(_super) {
  __extends(PointerEventInput2, _super);
  function PointerEventInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = SUPPORT_POINTER ? ["pointerdown"] : ["MSPointerDown"];
    _this.move = SUPPORT_POINTER ? ["pointermove"] : ["MSPointerMove"];
    _this.end = SUPPORT_POINTER ? ["pointerup", "pointercancel"] : ["MSPointerUp", "MSPointerCancel"];
    _this._firstInputs = [];
    _this._recentInputs = [];
    return _this;
  }
  var __proto = PointerEventInput2.prototype;
  __proto.onEventStart = function(event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function(event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function(event) {
    this._removePointerEvent(event);
  };
  __proto.onRelease = function() {
    this.prevEvent = null;
    this._firstInputs = [];
    this._recentInputs = [];
    return;
  };
  __proto.getTouches = function() {
    return this._recentInputs.length;
  };
  __proto._getScale = function() {
    if (this._recentInputs.length !== 2) {
      return null;
    }
    return this._getDistance(this._recentInputs[0], this._recentInputs[1]) / this._getDistance(this._firstInputs[0], this._firstInputs[1]);
  };
  __proto._getCenter = function(event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function(event) {
    var prev = this.prevEvent.srcEvent;
    if (event.pointerId !== prev.pointerId) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  __proto._updatePointerEvent = function(event) {
    var _this = this;
    var addFlag = false;
    this._recentInputs.forEach(function(e, i) {
      if (e.pointerId === event.pointerId) {
        addFlag = true;
        _this._recentInputs[i] = event;
      }
    });
    if (!addFlag) {
      this._firstInputs.push(event);
      this._recentInputs.push(event);
    }
  };
  __proto._removePointerEvent = function(event) {
    this._firstInputs = this._firstInputs.filter(function(x) {
      return x.pointerId !== event.pointerId;
    });
    this._recentInputs = this._recentInputs.filter(function(x) {
      return x.pointerId !== event.pointerId;
    });
  };
  return PointerEventInput2;
}(EventInput);
var TouchMouseEventInput = function(_super) {
  __extends(TouchMouseEventInput2, _super);
  function TouchMouseEventInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown", "touchstart"];
    _this.move = ["mousemove", "touchmove"];
    _this.end = ["mouseup", "touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchMouseEventInput2.prototype;
  __proto.onEventStart = function(event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function(event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function(event) {
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    return;
  };
  __proto.onRelease = function() {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function(event) {
    return this._isTouchEvent(event) ? event.touches.length : 0;
  };
  __proto._getScale = function(event) {
    if (this._isTouchEvent(event)) {
      if (event.touches.length !== 2 || this._baseTouches.length < 2) {
        return 1;
      }
      return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
    }
    return this.prevEvent.scale;
  };
  __proto._getCenter = function(event) {
    if (this._isTouchEvent(event)) {
      return {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };
    }
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function(event) {
    var _this = this;
    var prev = this.prevEvent.srcEvent;
    var _a2 = [event, prev].map(function(e) {
      if (_this._isTouchEvent(e)) {
        return {
          id: e.touches[0].identifier,
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        };
      }
      return {
        id: null,
        x: e.clientX,
        y: e.clientY
      };
    }), nextSpot = _a2[0], prevSpot = _a2[1];
    return nextSpot.id === prevSpot.id ? {
      x: nextSpot.x - prevSpot.x,
      y: nextSpot.y - prevSpot.y
    } : {
      x: 0,
      y: 0
    };
  };
  return TouchMouseEventInput2;
}(EventInput);
var toAxis = function(source, offset) {
  return offset.reduce(function(acc, v, i) {
    if (source[i]) {
      acc[source[i]] = v;
    }
    return acc;
  }, {});
};
var convertInputType = function(inputType) {
  if (inputType === void 0) {
    inputType = [];
  }
  var hasTouch = false;
  var hasMouse = false;
  var hasPointer = false;
  inputType.forEach(function(v) {
    switch (v) {
      case "mouse":
        hasMouse = true;
        break;
      case "touch":
        hasTouch = SUPPORT_TOUCH;
        break;
      case "pointer":
        hasPointer = SUPPORT_POINTER_EVENTS;
    }
  });
  if (hasPointer) {
    return new PointerEventInput();
  } else if (hasTouch && hasMouse) {
    return new TouchMouseEventInput();
  } else if (hasTouch) {
    return new TouchEventInput();
  } else if (hasMouse) {
    return new MouseEventInput();
  }
  return null;
};
function getAddEventOptions(eventName) {
  return eventName.indexOf("touch") > -1 ? {
    passive: false
  } : false;
}
var InputObserver = function() {
  function InputObserver2(_a2) {
    var options = _a2.options, interruptManager = _a2.interruptManager, eventManager = _a2.eventManager, axisManager = _a2.axisManager, animationManager = _a2.animationManager;
    this._isOutside = false;
    this._moveDistance = null;
    this._isStopped = false;
    this.options = options;
    this._interruptManager = interruptManager;
    this._eventManager = eventManager;
    this._axisManager = axisManager;
    this._animationManager = animationManager;
  }
  var __proto = InputObserver2.prototype;
  __proto.get = function(input) {
    return this._axisManager.get(input.axes);
  };
  __proto.hold = function(input, event) {
    if (this._interruptManager.isInterrupted() || !input.axes.length) {
      return;
    }
    var changeOption = {
      input,
      event
    };
    this._isStopped = false;
    this._interruptManager.setInterrupt(true);
    this._animationManager.stopAnimation(changeOption);
    if (!this._moveDistance) {
      this._eventManager.hold(this._axisManager.get(), changeOption);
    }
    this._isOutside = this._axisManager.isOutside(input.axes);
    this._moveDistance = this._axisManager.get(input.axes);
  };
  __proto.change = function(input, event, offset, useAnimation) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || this._axisManager.every(offset, function(v) {
      return v === 0;
    })) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyChanged) {
      return;
    }
    var depaPos = this._moveDistance || this._axisManager.get(input.axes);
    var destPos;
    destPos = map(depaPos, function(v, k) {
      return v + (offset[k] || 0);
    });
    if (this._moveDistance) {
      this._moveDistance = this._axisManager.map(destPos, function(v, _a2) {
        var circular = _a2.circular, range = _a2.range;
        return circular && (circular[0] || circular[1]) ? getCirculatedPos(v, range, circular) : v;
      });
    }
    if (this._isOutside && this._axisManager.every(depaPos, function(v, opt) {
      return !isOutside(v, opt.range);
    })) {
      this._isOutside = false;
    }
    depaPos = this._atOutside(depaPos);
    destPos = this._atOutside(destPos);
    if (!this.options.nested || !this._isEndofAxis(offset, depaPos, destPos)) {
      nativeEvent.__childrenAxesAlreadyChanged = true;
    }
    var changeOption = {
      input,
      event
    };
    if (useAnimation) {
      var duration = this._animationManager.getDuration(destPos, depaPos);
      this._animationManager.animateTo(destPos, duration, changeOption);
    } else {
      var isCanceled = !this._eventManager.triggerChange(destPos, depaPos, changeOption, true);
      if (isCanceled) {
        this._isStopped = true;
        this._moveDistance = null;
        this._animationManager.finish(false);
      }
    }
  };
  __proto.release = function(input, event, velocity, inputDuration) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || !this._moveDistance) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyReleased) {
      velocity = velocity.map(function() {
        return 0;
      });
    }
    var pos = this._axisManager.get(input.axes);
    var depaPos = this._axisManager.get();
    var displacement = this._animationManager.getDisplacement(velocity);
    var offset = toAxis(input.axes, displacement);
    var destPos = this._axisManager.get(this._axisManager.map(offset, function(v, opt, k) {
      if (opt.circular && (opt.circular[0] || opt.circular[1])) {
        return pos[k] + v;
      } else {
        return getInsidePosition(pos[k] + v, opt.range, opt.circular, opt.bounce);
      }
    }));
    nativeEvent.__childrenAxesAlreadyReleased = true;
    var duration = this._animationManager.getDuration(destPos, pos, inputDuration);
    if (duration === 0) {
      destPos = __assign({}, depaPos);
    }
    var param = {
      depaPos,
      destPos,
      duration,
      delta: this._axisManager.getDelta(depaPos, destPos),
      inputEvent: event,
      input,
      isTrusted: true
    };
    this._eventManager.triggerRelease(param);
    this._moveDistance = null;
    var userWish = this._animationManager.getUserControl(param);
    var isEqual = equal(userWish.destPos, depaPos);
    var changeOption = {
      input,
      event
    };
    if (isEqual || userWish.duration === 0) {
      if (!isEqual) {
        this._eventManager.triggerChange(userWish.destPos, depaPos, changeOption, true);
      }
      this._interruptManager.setInterrupt(false);
      if (this._axisManager.isOutside()) {
        this._animationManager.restore(changeOption);
      } else {
        this._eventManager.triggerFinish(true);
      }
    } else {
      this._animationManager.animateTo(userWish.destPos, userWish.duration, changeOption);
    }
  };
  __proto._atOutside = function(pos) {
    var _this = this;
    if (this._isOutside) {
      return this._axisManager.map(pos, function(v, opt) {
        var tn = opt.range[0] - opt.bounce[0];
        var tx = opt.range[1] + opt.bounce[1];
        return v > tx ? tx : v < tn ? tn : v;
      });
    } else {
      return this._axisManager.map(pos, function(v, opt) {
        var min = opt.range[0];
        var max = opt.range[1];
        var out = opt.bounce;
        var circular = opt.circular;
        if (circular[0] && v < min || circular[1] && v > max) {
          return v;
        } else if (v < min) {
          return min - _this._animationManager.interpolate(min - v, out[0]);
        } else if (v > max) {
          return max + _this._animationManager.interpolate(v - max, out[1]);
        }
        return v;
      });
    }
  };
  __proto._isEndofAxis = function(offset, depaPos, destPos) {
    return this._axisManager.every(depaPos, function(value, option, key) {
      return offset[key] === 0 || depaPos[key] === destPos[key] && isEndofBounce(value, option.range, option.bounce, option.circular);
    });
  };
  return InputObserver2;
}();
var clamp = function(value, min, max) {
  return Math.max(Math.min(value, max), min);
};
var AnimationManager = function() {
  function AnimationManager2(_a2) {
    var options = _a2.options, interruptManager = _a2.interruptManager, eventManager = _a2.eventManager, axisManager = _a2.axisManager;
    this._options = options;
    this.interruptManager = interruptManager;
    this.eventManager = eventManager;
    this.axisManager = axisManager;
    this.animationEnd = this.animationEnd.bind(this);
  }
  var __proto = AnimationManager2.prototype;
  __proto.getDuration = function(depaPos, destPos, wishDuration) {
    var _this = this;
    var duration;
    if (typeof wishDuration !== "undefined") {
      duration = wishDuration;
    } else {
      var durations_1 = map(destPos, function(v, k) {
        return getDuration(Math.abs(v - depaPos[k]), _this._options.deceleration);
      });
      duration = Object.keys(durations_1).reduce(function(max, v) {
        return Math.max(max, durations_1[v]);
      }, -Infinity);
    }
    return clamp(duration, this._options.minimumDuration, this._options.maximumDuration);
  };
  __proto.getDisplacement = function(velocity) {
    var totalVelocity = Math.pow(velocity.reduce(function(total, v) {
      return total + v * v;
    }, 0), 1 / velocity.length);
    var duration = Math.abs(totalVelocity / -this._options.deceleration);
    return velocity.map(function(v) {
      return v / 2 * duration;
    });
  };
  __proto.stopAnimation = function(option) {
    if (this._animateParam) {
      var orgPos_1 = this.axisManager.get();
      var pos = this.axisManager.map(orgPos_1, function(v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      });
      if (!every(pos, function(v, k) {
        return orgPos_1[k] === v;
      })) {
        this.eventManager.triggerChange(pos, orgPos_1, option, !!option);
      }
      this._animateParam = null;
      if (this._raf) {
        cancelAnimationFrame(this._raf);
      }
      this._raf = null;
      this.eventManager.triggerAnimationEnd(!!(option === null || option === void 0 ? void 0 : option.event));
    }
  };
  __proto.getEventInfo = function() {
    if (this._animateParam && this._animateParam.input && this._animateParam.inputEvent) {
      return {
        input: this._animateParam.input,
        event: this._animateParam.inputEvent
      };
    } else {
      return null;
    }
  };
  __proto.restore = function(option) {
    var pos = this.axisManager.get();
    var destPos = this.axisManager.map(pos, function(v, opt) {
      return Math.min(opt.range[1], Math.max(opt.range[0], v));
    });
    this.stopAnimation();
    this.animateTo(destPos, this.getDuration(pos, destPos), option);
  };
  __proto.animationEnd = function() {
    var beforeParam = this.getEventInfo();
    this._animateParam = null;
    var circularTargets = this.axisManager.filter(this.axisManager.get(), function(v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    });
    if (Object.keys(circularTargets).length > 0) {
      this.setTo(this.axisManager.map(circularTargets, function(v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      }));
    }
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerAnimationEnd(!!beforeParam);
    if (this.axisManager.isOutside()) {
      this.restore(beforeParam);
    } else {
      this.finish(!!beforeParam);
    }
  };
  __proto.finish = function(isTrusted) {
    this._animateParam = null;
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerFinish(isTrusted);
  };
  __proto.getUserControl = function(param) {
    var userWish = param.setTo();
    userWish.destPos = this.axisManager.get(userWish.destPos);
    userWish.duration = clamp(userWish.duration, this._options.minimumDuration, this._options.maximumDuration);
    return userWish;
  };
  __proto.animateTo = function(destPos, duration, option) {
    var _this = this;
    this.stopAnimation();
    var param = this._createAnimationParam(destPos, duration, option);
    var depaPos = __assign({}, param.depaPos);
    var retTrigger = this.eventManager.triggerAnimationStart(param);
    var userWish = this.getUserControl(param);
    if (!retTrigger && this.axisManager.every(userWish.destPos, function(v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    })) {
      console.warn("You can't stop the 'animation' event when 'circular' is true.");
    }
    if (retTrigger && !equal(userWish.destPos, depaPos)) {
      var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
      this._animateLoop({
        depaPos,
        destPos: userWish.destPos,
        duration: userWish.duration,
        delta: this.axisManager.getDelta(depaPos, userWish.destPos),
        isTrusted: !!inputEvent,
        inputEvent,
        input: (option === null || option === void 0 ? void 0 : option.input) || null
      }, function() {
        return _this.animationEnd();
      });
    }
  };
  __proto.setTo = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    var axes = Object.keys(pos);
    var orgPos = this.axisManager.get(axes);
    if (equal(pos, orgPos)) {
      return this;
    }
    this.interruptManager.setInterrupt(true);
    var movedPos = filter(pos, function(v, k) {
      return orgPos[k] !== v;
    });
    if (!Object.keys(movedPos).length) {
      return this;
    }
    movedPos = this.axisManager.map(movedPos, function(v, opt) {
      var range = opt.range, circular = opt.circular;
      if (circular && (circular[0] || circular[1])) {
        return v;
      } else {
        return getInsidePosition(v, range, circular);
      }
    });
    if (equal(movedPos, orgPos)) {
      return this;
    }
    if (duration > 0) {
      this.animateTo(movedPos, duration);
    } else {
      this.stopAnimation();
      this.eventManager.triggerChange(movedPos);
      this.finish(false);
    }
    return this;
  };
  __proto.setBy = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    return this.setTo(map(this.axisManager.get(Object.keys(pos)), function(v, k) {
      return v + pos[k];
    }), duration);
  };
  __proto._createAnimationParam = function(pos, duration, option) {
    var depaPos = this.axisManager.get();
    var destPos = pos;
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
    return {
      depaPos,
      destPos,
      duration: clamp(duration, this._options.minimumDuration, this._options.maximumDuration),
      delta: this.axisManager.getDelta(depaPos, destPos),
      inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || null,
      isTrusted: !!inputEvent,
      done: this.animationEnd
    };
  };
  __proto._animateLoop = function(param, complete) {
    var _this = this;
    if (param.duration) {
      this._animateParam = __assign(__assign({}, param), {
        startTime: (/* @__PURE__ */ new Date()).getTime()
      });
      var originalIntendedPos_1 = map(param.destPos, function(v) {
        return v;
      });
      var state_1 = this._initState(this._animateParam);
      var loop_1 = function() {
        _this._raf = null;
        var animateParam = _this._animateParam;
        var nextState = _this._getNextState(state_1);
        var isCanceled = !_this.eventManager.triggerChange(nextState.pos, state_1.pos);
        state_1 = nextState;
        if (nextState.finished) {
          animateParam.destPos = _this._getFinalPos(animateParam.destPos, originalIntendedPos_1);
          if (!equal(animateParam.destPos, _this.axisManager.get(Object.keys(animateParam.destPos)))) {
            _this.eventManager.triggerChange(animateParam.destPos, nextState.pos);
          }
          complete();
          return;
        } else if (isCanceled) {
          _this.finish(false);
        } else {
          _this._raf = requestAnimationFrame(loop_1);
        }
      };
      loop_1();
    } else {
      this.eventManager.triggerChange(param.destPos);
      complete();
    }
  };
  __proto._getFinalPos = function(destPos, originalIntendedPos) {
    var _this = this;
    var ERROR_LIMIT = 1e-6;
    var finalPos = map(destPos, function(value, key) {
      if (value >= originalIntendedPos[key] - ERROR_LIMIT && value <= originalIntendedPos[key] + ERROR_LIMIT) {
        return originalIntendedPos[key];
      } else {
        var roundUnit = _this._getRoundUnit(value, key);
        var result = roundNumber(value, roundUnit);
        return result;
      }
    });
    return finalPos;
  };
  __proto._getRoundUnit = function(val, key) {
    var roundUnit = this._options.round;
    var minRoundUnit = null;
    if (!roundUnit) {
      var options = this.axisManager.getAxisOptions(key);
      minRoundUnit = inversePow(Math.max(getDecimalPlace(options.range[0]), getDecimalPlace(options.range[1]), getDecimalPlace(val)));
    }
    return minRoundUnit || roundUnit;
  };
  return AnimationManager2;
}();
var EasingManager = function(_super) {
  __extends(EasingManager2, _super);
  function EasingManager2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._useDuration = true;
    return _this;
  }
  var __proto = EasingManager2.prototype;
  __proto.interpolate = function(displacement, threshold) {
    var initSlope = this._easing(1e-5) / 1e-5;
    return this._easing(displacement / (threshold * initSlope)) * threshold;
  };
  __proto.updateAnimation = function(options) {
    var _a2;
    var animateParam = this._animateParam;
    if (!animateParam) {
      return;
    }
    var diffTime = (/* @__PURE__ */ new Date()).getTime() - animateParam.startTime;
    var pos = (options === null || options === void 0 ? void 0 : options.destPos) || animateParam.destPos;
    var duration = (_a2 = options === null || options === void 0 ? void 0 : options.duration) !== null && _a2 !== void 0 ? _a2 : animateParam.duration;
    if ((options === null || options === void 0 ? void 0 : options.restart) || duration <= diffTime) {
      this.setTo(pos, duration - diffTime);
      return;
    }
    if (options === null || options === void 0 ? void 0 : options.destPos) {
      var currentPos = this.axisManager.get();
      this._initialEasingPer = this._prevEasingPer;
      animateParam.delta = this.axisManager.getDelta(currentPos, pos);
      animateParam.destPos = pos;
    }
    if (options === null || options === void 0 ? void 0 : options.duration) {
      var ratio = (diffTime + this._durationOffset) / animateParam.duration;
      this._durationOffset = ratio * duration - diffTime;
      animateParam.duration = duration;
    }
  };
  __proto._initState = function(info) {
    this._initialEasingPer = 0;
    this._prevEasingPer = 0;
    this._durationOffset = 0;
    return {
      pos: info.depaPos,
      easingPer: 0,
      finished: false
    };
  };
  __proto._getNextState = function(prevState) {
    var _this = this;
    var animateParam = this._animateParam;
    var prevPos = prevState.pos;
    var destPos = animateParam.destPos;
    var directions = map(prevPos, function(value, key) {
      return value <= destPos[key] ? 1 : -1;
    });
    var diffTime = (/* @__PURE__ */ new Date()).getTime() - animateParam.startTime;
    var ratio = (diffTime + this._durationOffset) / animateParam.duration;
    var easingPer = this._easing(ratio);
    var toPos = this.axisManager.map(prevPos, function(pos, options, key) {
      var nextPos = ratio >= 1 ? destPos[key] : pos + animateParam.delta[key] * (easingPer - _this._prevEasingPer) / (1 - _this._initialEasingPer);
      var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);
      if (nextPos !== circulatedPos) {
        var rangeOffset = directions[key] * (options.range[1] - options.range[0]);
        destPos[key] -= rangeOffset;
        prevPos[key] -= rangeOffset;
      }
      return circulatedPos;
    });
    this._prevEasingPer = easingPer;
    return {
      pos: toPos,
      easingPer,
      finished: easingPer >= 1
    };
  };
  __proto._easing = function(p) {
    return p > 1 ? 1 : this._options.easing(p);
  };
  return EasingManager2;
}(AnimationManager);
var Axes = function(_super) {
  __extends(Axes2, _super);
  function Axes2(axis, options, startPos) {
    if (axis === void 0) {
      axis = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (startPos === void 0) {
      startPos = {};
    }
    var _this = _super.call(this) || this;
    _this.axis = axis;
    _this._inputs = [];
    _this.options = __assign({
      easing: function(x) {
        return 1 - Math.pow(1 - x, 3);
      },
      interruptable: true,
      maximumDuration: Infinity,
      minimumDuration: 0,
      deceleration: 6e-4,
      round: null,
      nested: false
    }, options);
    Object.keys(startPos).forEach(function(key) {
      _this.axis[key].startPos = startPos[key];
    });
    _this.interruptManager = new InterruptManager(_this.options);
    _this.axisManager = new AxisManager(_this.axis);
    _this.eventManager = new EventManager(_this);
    _this.animationManager = new EasingManager(_this);
    _this.inputObserver = new InputObserver(_this);
    _this.eventManager.setAnimationManager(_this.animationManager);
    _this.eventManager.triggerChange(_this.axisManager.get());
    return _this;
  }
  var __proto = Axes2.prototype;
  __proto.connect = function(axes, inputType) {
    var mapped;
    if (typeof axes === "string") {
      mapped = axes.split(" ");
    } else {
      mapped = axes.concat();
    }
    if (~this._inputs.indexOf(inputType)) {
      this.disconnect(inputType);
    }
    inputType.mapAxes(mapped);
    inputType.connect(this.inputObserver);
    this._inputs.push(inputType);
    return this;
  };
  __proto.disconnect = function(inputType) {
    if (inputType) {
      var index = this._inputs.indexOf(inputType);
      if (index >= 0) {
        this._inputs[index].disconnect();
        this._inputs.splice(index, 1);
      }
    } else {
      this._inputs.forEach(function(v) {
        return v.disconnect();
      });
      this._inputs = [];
    }
    return this;
  };
  __proto.get = function(axes) {
    return this.axisManager.get(axes);
  };
  __proto.setTo = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setTo(pos, duration);
    return this;
  };
  __proto.setBy = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setBy(pos, duration);
    return this;
  };
  __proto.setOptions = function(options) {
    this.options = __assign(__assign({}, this.options), options);
    return this;
  };
  __proto.setAxis = function(axis) {
    this.axisManager.setAxis(axis);
    return this;
  };
  __proto.stopAnimation = function() {
    this.animationManager.stopAnimation();
    this.animationManager.finish(false);
    return this;
  };
  __proto.updateAnimation = function(options) {
    this.animationManager.updateAnimation(options);
    return this;
  };
  __proto.isBounceArea = function(axes) {
    return this.axisManager.isOutside(axes);
  };
  __proto.destroy = function() {
    this.disconnect();
    this.eventManager.destroy();
  };
  Axes2.VERSION = "3.8.4";
  Axes2.TRANSFORM = TRANSFORM;
  Axes2.DIRECTION_NONE = DIRECTION_NONE;
  Axes2.DIRECTION_LEFT = DIRECTION_LEFT;
  Axes2.DIRECTION_RIGHT = DIRECTION_RIGHT;
  Axes2.DIRECTION_UP = DIRECTION_UP;
  Axes2.DIRECTION_DOWN = DIRECTION_DOWN;
  Axes2.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  Axes2.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  Axes2.DIRECTION_ALL = DIRECTION_ALL;
  Axes2 = __decorate([ReactiveSubscribe2], Axes2);
  return Axes2;
}(component_esm_default);
var getDirectionByAngle = function(angle, thresholdAngle) {
  if (thresholdAngle < 0 || thresholdAngle > 90) {
    return DIRECTION_NONE;
  }
  var toAngle = Math.abs(angle);
  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle ? DIRECTION_VERTICAL : DIRECTION_HORIZONTAL;
};
var PanInput = function() {
  function PanInput2(el, options) {
    var _this = this;
    this.axes = [];
    this.element = null;
    this._enabled = false;
    this._activeEvent = null;
    this._atRightEdge = false;
    this._rightEdgeTimer = 0;
    this._dragged = false;
    this._isOverThreshold = false;
    this._preventClickWhenDragged = function(e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._voidFunction = function() {
    };
    this.element = $(el);
    this.options = __assign({
      inputType: ["touch", "mouse", "pointer"],
      inputKey: [ANY],
      inputButton: [MOUSE_LEFT],
      scale: [1, 1],
      thresholdAngle: 45,
      threshold: 0,
      preventClickOnDrag: false,
      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,
      releaseOnScroll: false,
      touchAction: null
    }, options);
    this._onPanstart = this._onPanstart.bind(this);
    this._onPanmove = this._onPanmove.bind(this);
    this._onPanend = this._onPanend.bind(this);
  }
  var __proto = PanInput2.prototype;
  __proto.mapAxes = function(axes) {
    this._direction = getDirection(!!axes[0], !!axes[1]);
    this.axes = axes;
  };
  __proto.connect = function(observer) {
    if (this._activeEvent) {
      this._detachElementEvent();
      this._detachWindowEvent(this._activeEvent);
    }
    this._attachElementEvent(observer);
    this._originalCssProps = setCssProps(this.element, this.options, this._direction);
    return this;
  };
  __proto.disconnect = function() {
    this._detachElementEvent();
    this._detachWindowEvent(this._activeEvent);
    if (!isCssPropsFromAxes(this._originalCssProps)) {
      revertCssProps(this.element, this._originalCssProps);
    }
    this._direction = DIRECTION_NONE;
    return this;
  };
  __proto.destroy = function() {
    this.disconnect();
    this.element = null;
  };
  __proto.enable = function() {
    this._enabled = true;
    return this;
  };
  __proto.disable = function() {
    this._enabled = false;
    return this;
  };
  __proto.isEnabled = function() {
    return this._enabled;
  };
  __proto.release = function() {
    var activeEvent = this._activeEvent;
    var prevEvent = activeEvent.prevEvent;
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, [0, 0]);
    this._detachWindowEvent(activeEvent);
    return this;
  };
  __proto._onPanstart = function(event) {
    var _a2 = this.options, inputKey = _a2.inputKey, inputButton = _a2.inputButton;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventStart(event, inputKey, inputButton);
    if (!panEvent || !this._enabled || activeEvent.getTouches(event, inputButton) > 1) {
      return;
    }
    if (panEvent.srcEvent.cancelable !== false) {
      var edgeThreshold = this.options.iOSEdgeSwipeThreshold;
      this._dragged = false;
      this._isOverThreshold = false;
      this._observer.hold(this, panEvent);
      this._atRightEdge = IS_IOS_SAFARI && panEvent.center.x > window.innerWidth - edgeThreshold;
      this._attachWindowEvent(activeEvent);
      activeEvent.prevEvent = panEvent;
    }
  };
  __proto._onPanmove = function(event) {
    var _this = this;
    var _a2 = this.options, iOSEdgeSwipeThreshold = _a2.iOSEdgeSwipeThreshold, preventClickOnDrag = _a2.preventClickOnDrag, releaseOnScroll = _a2.releaseOnScroll, inputKey = _a2.inputKey, inputButton = _a2.inputButton, threshold = _a2.threshold, thresholdAngle = _a2.thresholdAngle;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventMove(event, inputKey, inputButton);
    var touches = activeEvent.getTouches(event, inputButton);
    if (touches === 0 || releaseOnScroll && panEvent && !panEvent.srcEvent.cancelable) {
      this._onPanend(event);
      return;
    }
    if (!panEvent || !this._enabled || touches > 1) {
      return;
    }
    var userDirection = getDirectionByAngle(panEvent.angle, thresholdAngle);
    var useHorizontal = useDirection(DIRECTION_HORIZONTAL, this._direction, userDirection);
    var useVertical = useDirection(DIRECTION_VERTICAL, this._direction, userDirection);
    if (activeEvent.prevEvent && IS_IOS_SAFARI) {
      var swipeLeftToRight = panEvent.center.x < 0;
      if (swipeLeftToRight) {
        this.release();
        return;
      } else if (this._atRightEdge) {
        clearTimeout(this._rightEdgeTimer);
        var swipeRightToLeft = panEvent.deltaX < -iOSEdgeSwipeThreshold;
        if (swipeRightToLeft) {
          this._atRightEdge = false;
        } else {
          this._rightEdgeTimer = window.setTimeout(function() {
            return _this.release();
          }, 100);
        }
      }
    }
    var distance = this._getDistance([panEvent.deltaX, panEvent.deltaY], [useHorizontal, useVertical]);
    var offset = this._getOffset([panEvent.offsetX, panEvent.offsetY], [useHorizontal, useVertical]);
    var prevent = offset.some(function(v) {
      return v !== 0;
    });
    if (prevent) {
      if (panEvent.srcEvent.cancelable !== false) {
        panEvent.srcEvent.preventDefault();
      }
      panEvent.srcEvent.stopPropagation();
    }
    panEvent.preventSystemEvent = prevent;
    if (prevent && (this._isOverThreshold || distance >= threshold)) {
      this._dragged = preventClickOnDrag;
      this._isOverThreshold = true;
      this._observer.change(this, panEvent, toAxis(this.axes, offset));
    }
    activeEvent.prevEvent = panEvent;
  };
  __proto._onPanend = function(event) {
    var inputButton = this.options.inputButton;
    var activeEvent = this._activeEvent;
    activeEvent.onEventEnd(event);
    if (!this._enabled || activeEvent.getTouches(event, inputButton) !== 0) {
      return;
    }
    this._detachWindowEvent(activeEvent);
    clearTimeout(this._rightEdgeTimer);
    var prevEvent = activeEvent.prevEvent;
    var velocity = this._isOverThreshold ? this._getOffset([Math.abs(prevEvent.velocityX) * (prevEvent.offsetX < 0 ? -1 : 1), Math.abs(prevEvent.velocityY) * (prevEvent.offsetY < 0 ? -1 : 1)], [useDirection(DIRECTION_HORIZONTAL, this._direction), useDirection(DIRECTION_VERTICAL, this._direction)]) : [0, 0];
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, velocity);
  };
  __proto._attachWindowEvent = function(activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function(event) {
      window.addEventListener(event, _this._onPanmove, getAddEventOptions(event));
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function(event) {
      window.addEventListener(event, _this._onPanend, getAddEventOptions(event));
    });
  };
  __proto._detachWindowEvent = function(activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function(event) {
      window.removeEventListener(event, _this._onPanmove);
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function(event) {
      window.removeEventListener(event, _this._onPanend);
    });
  };
  __proto._getOffset = function(properties, direction) {
    var scale = this.options.scale;
    return [direction[0] ? properties[0] * scale[0] : 0, direction[1] ? properties[1] * scale[1] : 0];
  };
  __proto._getDistance = function(delta, direction) {
    return Math.sqrt(Number(direction[0]) * Math.pow(delta[0], 2) + Number(direction[1]) * Math.pow(delta[1], 2));
  };
  __proto._attachElementEvent = function(observer) {
    var _this = this;
    var activeEvent = convertInputType(this.options.inputType);
    var element = this.element;
    if (!activeEvent) {
      return;
    }
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    this._enabled = true;
    this._activeEvent = activeEvent;
    element.addEventListener("click", this._preventClickWhenDragged, true);
    activeEvent.start.forEach(function(event) {
      element.addEventListener(event, _this._onPanstart);
    });
    activeEvent.move.forEach(function(event) {
      element.addEventListener(event, _this._voidFunction);
    });
  };
  __proto._detachElementEvent = function() {
    var _this = this;
    var activeEvent = this._activeEvent;
    var element = this.element;
    if (element) {
      element.removeEventListener("click", this._preventClickWhenDragged, true);
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.start.forEach(function(event) {
        element.removeEventListener(event, _this._onPanstart);
      });
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function(event) {
        element.removeEventListener(event, _this._voidFunction);
      });
    }
    this._enabled = false;
    this._observer = null;
  };
  return PanInput2;
}();
var RotatePanInput = function(_super) {
  __extends(RotatePanInput2, _super);
  function RotatePanInput2(el, options) {
    var _this = _super.call(this, el, options) || this;
    _this._prevQuadrant = null;
    _this._lastDiff = 0;
    return _this;
  }
  var __proto = RotatePanInput2.prototype;
  __proto.mapAxes = function(axes) {
    this._direction = Axes.DIRECTION_ALL;
    this.axes = axes;
  };
  __proto._onPanstart = function(event) {
    var _a2 = this.options, inputKey = _a2.inputKey, inputButton = _a2.inputButton;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventStart(event, inputKey, inputButton);
    if (!panEvent || !this.isEnabled()) {
      return;
    }
    var rect = this.element.getBoundingClientRect();
    this._observer.hold(this, panEvent);
    this._attachWindowEvent(activeEvent);
    this._coefficientForDistanceToAngle = 360 / (rect.width * Math.PI);
    this._rotateOrigin = [rect.left + (rect.width - 1) / 2, rect.top + (rect.height - 1) / 2];
    this._prevAngle = null;
    this._triggerChange(panEvent);
    activeEvent.prevEvent = panEvent;
  };
  __proto._onPanmove = function(event) {
    var _a2 = this.options, inputKey = _a2.inputKey, inputButton = _a2.inputButton;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventMove(event, inputKey, inputButton);
    if (!panEvent || !this.isEnabled()) {
      return;
    }
    if (panEvent.srcEvent.cancelable !== false) {
      panEvent.srcEvent.preventDefault();
    }
    panEvent.srcEvent.stopPropagation();
    this._triggerChange(panEvent);
    activeEvent.prevEvent = panEvent;
  };
  __proto._onPanend = function(event) {
    var activeEvent = this._activeEvent;
    activeEvent.onEventEnd(event);
    if (!this.isEnabled()) {
      return;
    }
    var prevEvent = activeEvent.prevEvent;
    this._triggerChange(prevEvent);
    var vx = prevEvent.velocityX;
    var vy = prevEvent.velocityY;
    var velocity = Math.sqrt(vx * vx + vy * vy) * (this._lastDiff > 0 ? -1 : 1);
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, [velocity * this._coefficientForDistanceToAngle]);
    this._detachWindowEvent(activeEvent);
  };
  __proto._triggerChange = function(event) {
    var _a2 = this._getPosFromOrigin(event.center.x, event.center.y), x = _a2.x, y = _a2.y;
    var angle = getAngle(x, y);
    var positiveAngle = angle < 0 ? 360 + angle : angle;
    var quadrant = this._getQuadrant(event.center.x, event.center.y);
    var diff = this._getDifference(this._prevAngle, positiveAngle, this._prevQuadrant, quadrant);
    this._prevAngle = positiveAngle;
    this._prevQuadrant = quadrant;
    if (diff === 0) {
      return;
    }
    this._lastDiff = diff;
    this._observer.change(this, event, toAxis(this.axes, [-diff]));
  };
  __proto._getDifference = function(prevAngle, angle, prevQuadrant, quadrant) {
    var diff;
    if (prevAngle === null) {
      diff = 0;
    } else if (prevQuadrant === 1 && quadrant === 4) {
      diff = -prevAngle - (360 - angle);
    } else if (prevQuadrant === 4 && quadrant === 1) {
      diff = 360 - prevAngle + angle;
    } else {
      diff = angle - prevAngle;
    }
    return diff;
  };
  __proto._getPosFromOrigin = function(posX, posY) {
    return {
      x: posX - this._rotateOrigin[0],
      y: this._rotateOrigin[1] - posY
    };
  };
  __proto._getQuadrant = function(posX, posY) {
    var _a2 = this._getPosFromOrigin(posX, posY), x = _a2.x, y = _a2.y;
    var q = 0;
    if (x >= 0 && y >= 0) {
      q = 1;
    } else if (x < 0 && y >= 0) {
      q = 2;
    } else if (x < 0 && y < 0) {
      q = 3;
    } else if (x >= 0 && y < 0) {
      q = 4;
    }
    return q;
  };
  return RotatePanInput2;
}(PanInput);
var PinchInput = function() {
  function PinchInput2(el, options) {
    this.axes = [];
    this.element = null;
    this._pinchFlag = false;
    this._enabled = false;
    this._activeEvent = null;
    this._isOverThreshold = false;
    this.element = $(el);
    this.options = __assign({
      scale: 1,
      threshold: 0,
      inputType: ["touch", "pointer"],
      touchAction: "none"
    }, options);
    this._onPinchStart = this._onPinchStart.bind(this);
    this._onPinchMove = this._onPinchMove.bind(this);
    this._onPinchEnd = this._onPinchEnd.bind(this);
  }
  var __proto = PinchInput2.prototype;
  __proto.mapAxes = function(axes) {
    this.axes = axes;
  };
  __proto.connect = function(observer) {
    if (this._activeEvent) {
      this._detachEvent();
    }
    this._attachEvent(observer);
    this._originalCssProps = setCssProps(this.element, this.options, DIRECTION_ALL);
    return this;
  };
  __proto.disconnect = function() {
    this._detachEvent();
    if (!isCssPropsFromAxes(this._originalCssProps)) {
      revertCssProps(this.element, this._originalCssProps);
    }
    return this;
  };
  __proto.destroy = function() {
    this.disconnect();
    this.element = null;
  };
  __proto.enable = function() {
    this._enabled = true;
    return this;
  };
  __proto.disable = function() {
    this._enabled = false;
    return this;
  };
  __proto.isEnabled = function() {
    return this._enabled;
  };
  __proto._onPinchStart = function(event) {
    var activeEvent = this._activeEvent;
    var pinchEvent = activeEvent.onEventStart(event);
    if (!pinchEvent || !this._enabled || activeEvent.getTouches(event) !== 2) {
      return;
    }
    this._baseValue = this._observer.get(this)[this.axes[0]];
    this._observer.hold(this, event);
    this._pinchFlag = true;
    this._isOverThreshold = false;
    activeEvent.prevEvent = pinchEvent;
  };
  __proto._onPinchMove = function(event) {
    var threshold = this.options.threshold;
    var activeEvent = this._activeEvent;
    var pinchEvent = activeEvent.onEventMove(event);
    if (!pinchEvent || !this._pinchFlag || !this._enabled || activeEvent.getTouches(event) !== 2) {
      return;
    }
    var distance = this._getDistance(pinchEvent.scale);
    var offset = this._getOffset(pinchEvent.scale, activeEvent.prevEvent.scale);
    if (this._isOverThreshold || distance >= threshold) {
      this._isOverThreshold = true;
      this._observer.change(this, event, toAxis(this.axes, [offset]));
    }
    activeEvent.prevEvent = pinchEvent;
  };
  __proto._onPinchEnd = function(event) {
    var activeEvent = this._activeEvent;
    activeEvent.onEventEnd(event);
    if (!this._pinchFlag || !this._enabled || activeEvent.getTouches(event) >= 2) {
      return;
    }
    activeEvent.onRelease();
    this._observer.release(this, event, [0], 0);
    this._baseValue = null;
    this._pinchFlag = false;
  };
  __proto._attachEvent = function(observer) {
    var _this = this;
    var activeEvent = convertInputType(this.options.inputType);
    var element = this.element;
    if (!activeEvent) {
      return;
    }
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    this._enabled = true;
    this._activeEvent = activeEvent;
    activeEvent.start.forEach(function(event) {
      element.addEventListener(event, _this._onPinchStart, false);
    });
    activeEvent.move.forEach(function(event) {
      element.addEventListener(event, _this._onPinchMove, false);
    });
    activeEvent.end.forEach(function(event) {
      element.addEventListener(event, _this._onPinchEnd, false);
    });
  };
  __proto._detachEvent = function() {
    var _this = this;
    var activeEvent = this._activeEvent;
    var element = this.element;
    if (element) {
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.start.forEach(function(event) {
        element.removeEventListener(event, _this._onPinchStart, false);
      });
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function(event) {
        element.removeEventListener(event, _this._onPinchMove, false);
      });
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function(event) {
        element.removeEventListener(event, _this._onPinchEnd, false);
      });
    }
    this._enabled = false;
    this._observer = null;
  };
  __proto._getOffset = function(pinchScale, prev) {
    if (prev === void 0) {
      prev = 1;
    }
    return this._baseValue * (pinchScale - prev) * this.options.scale;
  };
  __proto._getDistance = function(pinchScale) {
    return Math.abs(pinchScale - 1);
  };
  return PinchInput2;
}();
var WheelInput = function() {
  function WheelInput2(el, options) {
    this.axes = [];
    this.element = null;
    this._enabled = false;
    this._holding = false;
    this._timer = null;
    this.element = $(el);
    this.options = __assign({
      inputKey: [ANY],
      scale: 1,
      releaseDelay: 300,
      useNormalized: true,
      useAnimation: false
    }, options);
    this._onWheel = this._onWheel.bind(this);
  }
  var __proto = WheelInput2.prototype;
  __proto.mapAxes = function(axes) {
    this._direction = getDirection(!!axes[1], !!axes[0]);
    this.axes = axes;
  };
  __proto.connect = function(observer) {
    this._detachEvent();
    this._attachEvent(observer);
    return this;
  };
  __proto.disconnect = function() {
    this._detachEvent();
    return this;
  };
  __proto.destroy = function() {
    this.disconnect();
    this.element = null;
  };
  __proto.enable = function() {
    this._enabled = true;
    return this;
  };
  __proto.disable = function() {
    this._enabled = false;
    return this;
  };
  __proto.isEnabled = function() {
    return this._enabled;
  };
  __proto._onWheel = function(event) {
    var _this = this;
    if (!this._enabled || !isValidKey(event, this.options.inputKey)) {
      return;
    }
    var offset = this._getOffset([event.deltaY, event.deltaX], [useDirection(DIRECTION_VERTICAL, this._direction), useDirection(DIRECTION_HORIZONTAL, this._direction)]);
    if (offset[0] === 0 && offset[1] === 0) {
      return;
    }
    event.preventDefault();
    if (!this._holding) {
      this._observer.hold(this, event);
      this._holding = true;
    }
    this._observer.change(this, event, toAxis(this.axes, offset), this.options.useAnimation);
    clearTimeout(this._timer);
    this._timer = setTimeout(function() {
      if (_this._holding) {
        _this._holding = false;
        _this._observer.release(_this, event, [0]);
      }
    }, this.options.releaseDelay);
  };
  __proto._getOffset = function(properties, direction) {
    var scale = this.options.scale;
    var useNormalized = this.options.useNormalized;
    return [direction[0] && properties[0] ? (properties[0] > 0 ? -1 : 1) * (useNormalized ? 1 : Math.abs(properties[0])) * scale : 0, direction[1] && properties[1] ? (properties[1] > 0 ? -1 : 1) * (useNormalized ? 1 : Math.abs(properties[1])) * scale : 0];
  };
  __proto._attachEvent = function(observer) {
    var element = this.element;
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    element.addEventListener("wheel", this._onWheel);
    this._enabled = true;
  };
  __proto._detachEvent = function() {
    var element = this.element;
    if (element) {
      this.element.removeEventListener("wheel", this._onWheel);
    }
    this._enabled = false;
    this._observer = null;
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  };
  return WheelInput2;
}();
var KEY_LEFT_ARROW = 37;
var KEY_A = 65;
var KEY_UP_ARROW = 38;
var KEY_W = 87;
var KEY_RIGHT_ARROW = 39;
var KEY_D = 68;
var KEY_DOWN_ARROW = 40;
var KEY_S = 83;
var DIRECTION_REVERSE = -1;
var DIRECTION_FORWARD = 1;
var DIRECTION_HORIZONTAL$1 = -1;
var DIRECTION_VERTICAL$1 = 1;
var DELAY = 80;
var MoveKeyInput = function() {
  function MoveKeyInput2(el, options) {
    this.axes = [];
    this.element = null;
    this._enabled = false;
    this._holding = false;
    this._timer = null;
    this.element = $(el);
    this.options = __assign({
      scale: [1, 1]
    }, options);
    this._onKeydown = this._onKeydown.bind(this);
    this._onKeyup = this._onKeyup.bind(this);
  }
  var __proto = MoveKeyInput2.prototype;
  __proto.mapAxes = function(axes) {
    this.axes = axes;
  };
  __proto.connect = function(observer) {
    this._detachEvent();
    if (this.element.getAttribute("tabindex") !== "0") {
      this.element.setAttribute("tabindex", "0");
    }
    this._attachEvent(observer);
    return this;
  };
  __proto.disconnect = function() {
    this._detachEvent();
    return this;
  };
  __proto.destroy = function() {
    this.disconnect();
    this.element = null;
  };
  __proto.enable = function() {
    this._enabled = true;
    return this;
  };
  __proto.disable = function() {
    this._enabled = false;
    return this;
  };
  __proto.isEnabled = function() {
    return this._enabled;
  };
  __proto._onKeydown = function(event) {
    if (!this._enabled) {
      return;
    }
    var isMoveKey = true;
    var direction = DIRECTION_FORWARD;
    var move = DIRECTION_HORIZONTAL$1;
    switch (event.keyCode) {
      case KEY_LEFT_ARROW:
      case KEY_A:
        direction = DIRECTION_REVERSE;
        break;
      case KEY_RIGHT_ARROW:
      case KEY_D:
        break;
      case KEY_DOWN_ARROW:
      case KEY_S:
        direction = DIRECTION_REVERSE;
        move = DIRECTION_VERTICAL$1;
        break;
      case KEY_UP_ARROW:
      case KEY_W:
        move = DIRECTION_VERTICAL$1;
        break;
      default:
        isMoveKey = false;
    }
    if (move === DIRECTION_HORIZONTAL$1 && !this.axes[0] || move === DIRECTION_VERTICAL$1 && !this.axes[1]) {
      isMoveKey = false;
    }
    if (!isMoveKey) {
      return;
    }
    event.preventDefault();
    var offsets = move === DIRECTION_HORIZONTAL$1 ? [+this.options.scale[0] * direction, 0] : [0, +this.options.scale[1] * direction];
    if (!this._holding) {
      this._observer.hold(this, event);
      this._holding = true;
    }
    clearTimeout(this._timer);
    this._observer.change(this, event, toAxis(this.axes, offsets));
  };
  __proto._onKeyup = function(event) {
    var _this = this;
    if (!this._holding) {
      return;
    }
    clearTimeout(this._timer);
    this._timer = setTimeout(function() {
      _this._observer.release(_this, event, [0, 0]);
      _this._holding = false;
    }, DELAY);
  };
  __proto._attachEvent = function(observer) {
    var element = this.element;
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    element.addEventListener("keydown", this._onKeydown, false);
    element.addEventListener("keypress", this._onKeydown, false);
    element.addEventListener("keyup", this._onKeyup, false);
    this._enabled = true;
  };
  __proto._detachEvent = function() {
    var element = this.element;
    if (element) {
      element.removeEventListener("keydown", this._onKeydown, false);
      element.removeEventListener("keypress", this._onKeydown, false);
      element.removeEventListener("keyup", this._onKeyup, false);
    }
    this._enabled = false;
    this._observer = null;
  };
  return MoveKeyInput2;
}();
var axes_esm_default = Axes;

// node_modules/@egjs/conveyer/dist/conveyer.esm.js
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var _a;
var _b;
var IS_IE = /msie|trident/g.test(typeof window !== "undefined" && ((_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || "");
function isString(val) {
  return typeof val === "string";
}
var Conveyer = function(_super) {
  __extends2(Conveyer2, _super);
  function Conveyer2(scrollArea, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this._axes = null;
    _this._items = [];
    _this._size = 0;
    _this._scrollSize = 0;
    _this._scrollTimer = 0;
    _this._isDragScroll = false;
    _this._isAnimation = false;
    _this._isReachStart = true;
    _this._isReachEnd = false;
    _this._pos = 0;
    _this.update = function() {
      _this.updateItems();
      _this.updateContainer();
    };
    _this._onScroll = function(e) {
      if (e) {
        _this._debounceScroll();
      }
      _this._refreshScroll();
      var size = _this._size;
      var scrollSize = _this._scrollSize;
      var pos = _this._pos;
      if (pos <= 0 && _this.isReachStart !== true) {
        _this._isReachStart = true;
        _this.trigger("reachStart");
      } else if (pos > 0 && _this.isReachStart !== false) {
        _this._isReachStart = false;
        _this.trigger("leaveStart");
      }
      if (scrollSize - size - pos < 1 && _this.isReachEnd !== true) {
        _this._isReachEnd = true;
        _this.trigger("reachEnd");
      } else if (!(scrollSize - size - pos < 1) && _this.isReachEnd !== false) {
        _this._isReachEnd = false;
        _this.trigger("leaveEnd");
      }
    };
    _this._onPreventClick = function(e) {
      e.stopPropagation();
      e.preventDefault();
      _this._enableClick();
    };
    _this._options = __assign2({
      horizontal: true,
      useDrag: true,
      useSideWheel: false,
      autoInit: true,
      scrollDebounce: 100
    }, options);
    _this._scrollArea = scrollArea;
    if (_this._options.autoInit) {
      _this.init();
    }
    return _this;
  }
  var __proto = Conveyer2.prototype;
  __proto.findElement = function(direction, options) {
    var _a2;
    if (options === void 0) {
      options = {};
    }
    return ((_a2 = this.findItem(direction, options)) === null || _a2 === void 0 ? void 0 : _a2.element) || null;
  };
  __proto.findItem = function(target, options) {
    var _a2;
    if (options === void 0) {
      options = {};
    }
    var pos = this._pos;
    var scrollSize = this._scrollSize;
    var size = this._size;
    var hitTest = (_a2 = options === null || options === void 0 ? void 0 : options.hitTest) !== null && _a2 !== void 0 ? _a2 : 1;
    var items = __spreadArray([], this._items, true);
    var length = items.length;
    var endPos = pos + size;
    var sibling = options.sibling;
    var startVirtualItem = {
      pos: 0,
      size: 0
    };
    var endVirtualItem = {
      pos: scrollSize,
      size: 0
    };
    if (items[0].pos > 0) {
      items.unshift(startVirtualItem);
    }
    if (length && items[length - 1].pos + items[length - 1].size < scrollSize) {
      items.push(endVirtualItem);
    }
    var selectedItem;
    if (target === "start") {
      if (pos < 0) {
        return null;
      }
      var selectedItems = __spreadArray([], items, true).reverse().filter(function(item) {
        var itemSize = item.size;
        var dist = item.pos - pos;
        var dist2 = dist + itemSize;
        return dist >= 0 || dist2 >= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest);
      }).reverse();
      selectedItem = selectedItems[0] === startVirtualItem && selectedItems[1] || selectedItems[0];
    } else if (target === "end") {
      if (pos > scrollSize - size) {
        return null;
      }
      var selectedItems = items.filter(function(item) {
        var itemSize = item.size;
        var dist = item.pos + itemSize - endPos;
        var dist2 = dist - itemSize;
        return dist <= 0 || dist2 <= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest);
      }).reverse();
      selectedItem = selectedItems[0] === endVirtualItem && selectedItems[1] || selectedItems[0];
    } else if (target === "prev") {
      selectedItem = items.filter(function(item) {
        var itemSize = item.size;
        var dist = item.pos + itemSize - pos;
        var dist2 = dist - itemSize;
        return dist <= 0 || dist2 <= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest);
      }).reverse()[0];
    } else if (target === "next") {
      selectedItem = items.reverse().filter(function(item) {
        var itemSize = item.size;
        var dist = item.pos - endPos;
        var dist2 = dist + itemSize;
        return dist >= 0 || dist2 >= 0 && (!itemSize || Math.abs(dist2) / itemSize >= hitTest);
      }).reverse()[0];
    } else {
      return this._getItem(target);
    }
    if (sibling && selectedItem) {
      var selectedIndex = items.indexOf(selectedItem);
      if (selectedIndex > -1) {
        selectedItem = items[selectedIndex + sibling];
      }
    }
    return selectedItem || null;
  };
  __proto.scrollIntoView = function(target, options) {
    if (options === void 0) {
      options = {};
    }
    var item = this.findItem(target, options);
    if (!item) {
      return;
    }
    var duration = options.duration || 0;
    var nextScrollPos = this._getNextScrollPos(item, options);
    if (isString(target) && options.excludeStand && nextScrollPos === this._pos) {
      var selectedIndex = this._items.indexOf(item);
      if (selectedIndex === -1) {
        return;
      }
      var sibling = target === "start" || target === "prev" ? -1 : 1;
      item = this._items[selectedIndex + sibling];
      if (!item) {
        return;
      }
      nextScrollPos = this._getNextScrollPos(item, options);
    }
    this.scrollBy(nextScrollPos - this._pos, duration);
  };
  __proto.scrollBy = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this._axes.setBy({
      scroll: -pos
    }, duration);
  };
  __proto.scrollTo = function(pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this._axes.setBy({
      scroll: this._pos - pos
    }, duration);
  };
  __proto.setItems = function(items) {
    this._items = items;
  };
  __proto.updateItems = function() {
    var _this = this;
    var scrollAreaElement = this._scrollAreaElement;
    var itemSelector = this._options.itemSelector;
    var itemElements = [].slice.call(itemSelector ? scrollAreaElement.querySelectorAll(itemSelector) : scrollAreaElement.children);
    this.setItems(itemElements.map(function(el) {
      return _this._getItem(el);
    }));
  };
  __proto.updateContainer = function() {
    var scrollAreaElement = this._scrollAreaElement;
    var horizontal = this._options.horizontal;
    var size = horizontal ? scrollAreaElement.clientWidth : scrollAreaElement.clientHeight;
    var scrollSize = horizontal ? scrollAreaElement.scrollWidth : scrollAreaElement.scrollHeight;
    if (IS_IE && scrollSize === size + 1) {
      var style = getComputedStyle(scrollAreaElement);
      var boxSizing = style.boxSizing;
      var borderSize = horizontal ? (parseFloat(style.borderLeftWidth) || 0) + (parseFloat(style.borderRightWidth) || 0) : (parseFloat(style.borderTopWidth) || 0) + (parseFloat(style.borderBottomWidth) || 0);
      var cssSize = parseFloat(horizontal ? style.width : style.height) || 0;
      var contentSize = cssSize - (boxSizing === "border-box" ? borderSize : 0);
      if (size < contentSize && contentSize < size + 1) {
        scrollSize = size;
      }
    }
    this._size = size;
    this._scrollSize = scrollSize;
    this._refreshScroll();
    this._onScroll();
  };
  __proto.init = function() {
    var _this = this;
    if (this._axes) {
      return;
    }
    var scrollArea = this._scrollArea;
    var el;
    if (isString(scrollArea)) {
      el = document.querySelector(scrollArea);
    } else if (scrollArea instanceof Element) {
      el = scrollArea;
    } else if ("value" in scrollArea || "current" in scrollArea) {
      el = scrollArea.value || scrollArea.current;
    }
    this._scrollAreaElement = el;
    var isDrag = false;
    var scrollAreaElement = this._scrollAreaElement;
    var options = this._options;
    var axes = new axes_esm_default({
      scroll: {
        range: [-Infinity, Infinity]
      }
    }, {
      deceleration: 5e-3,
      round: 1,
      nested: options.nested
    }, {
      scroll: 0
    });
    var isHold = false;
    axes.on({
      "hold": function(e) {
        isHold = true;
        isDrag = false;
        var nativeEvent = _this._getNativeEvent(e);
        if (!nativeEvent) {
          return;
        }
        if (options.preventDefault) {
          nativeEvent.preventDefault();
        }
        if (options.preventClickOnDrag) {
          _this._disableClick();
        }
      },
      "change": function(e) {
        var nativeEvent = _this._getNativeEvent(e);
        if (nativeEvent && !isHold) {
          return;
        }
        if (options.useSideWheel && _this._isMixedWheel(nativeEvent)) {
          return;
        }
        _this._isDragScroll = !!nativeEvent && nativeEvent.type !== "wheel";
        _this._isAnimation = !!isHold;
        isDrag = true;
        var scroll = e.delta.scroll;
        if (options.horizontal) {
          scrollAreaElement.scrollLeft -= scroll;
        } else {
          scrollAreaElement.scrollTop -= scroll;
        }
        if (options.nested) {
          _this._checkNestedMove(nativeEvent);
        }
      },
      "release": function(e) {
        if (!isDrag) {
          e.setTo(__assign2({}, e.depaPos), 0);
          _this._enableClick();
        }
        isDrag = false;
      }
    });
    this._axes = axes;
    if (options.useDrag) {
      axes.connect(options.horizontal ? ["scroll", ""] : ["", "scroll"], new PanInput(scrollAreaElement, {
        inputType: ["mouse"],
        touchAction: "auto"
      }));
    }
    if (options.useSideWheel) {
      axes.connect(options.horizontal ? ["scroll", ""] : ["", "scroll"], new WheelInput(scrollAreaElement, {
        useNormalized: false
      }));
    }
    scrollAreaElement.addEventListener("scroll", this._onScroll);
    window.addEventListener("resize", this.update);
    this.update();
  };
  __proto.destroy = function() {
    var _a2, _b2;
    (_a2 = this._axes) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    this.unsubscribe();
    (_b2 = this._scrollAreaElement) === null || _b2 === void 0 ? void 0 : _b2.removeEventListener("scroll", this._onScroll);
    if (typeof window !== "undefined") {
      window.removeEventListener("resize", this.update);
    }
    this.off();
    this._axes = null;
  };
  __proto._refreshScroll = function() {
    var horizontal = this._options.horizontal;
    var scrollAreaElement = this._scrollAreaElement;
    this._pos = Math.min(this._scrollSize - this._size, horizontal ? scrollAreaElement.scrollLeft : scrollAreaElement.scrollTop);
  };
  __proto._getItem = function(element) {
    var horizontal = this._options.horizontal;
    return {
      element,
      pos: horizontal ? element.offsetLeft : element.offsetTop,
      size: horizontal ? element.offsetWidth : element.offsetHeight
    };
  };
  __proto._getNativeEvent = function(e) {
    var _a2, _b2;
    return ((_a2 = e === null || e === void 0 ? void 0 : e.inputEvent) === null || _a2 === void 0 ? void 0 : _a2.srcEvent) ? (_b2 = e.inputEvent) === null || _b2 === void 0 ? void 0 : _b2.srcEvent : e === null || e === void 0 ? void 0 : e.inputEvent;
  };
  __proto._getNextScrollPos = function(item, options) {
    var size = this._size;
    var align = options.align || "start";
    var padding = options.offset || 0;
    var itemPos = item.pos;
    var itemSize = item.size;
    var scrollPos = 0;
    if (align === "start") {
      scrollPos = itemPos - padding;
    } else if (align === "end") {
      scrollPos = itemPos + itemSize - size + padding;
    } else if (align === "center") {
      scrollPos = itemPos + itemSize / 2 - size / 2 + padding;
    }
    return scrollPos;
  };
  __proto._isMixedWheel = function(nativeEvent) {
    return !!nativeEvent && (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.type) === "wheel" && (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.deltaX) && (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.deltaY);
  };
  __proto._checkNestedMove = function(nativeEvent) {
    if (this.isReachStart || this.isReachEnd) {
      nativeEvent.__childrenAxesAlreadyChanged = false;
    }
  };
  __proto._enableClick = function() {
    window.removeEventListener("click", this._onPreventClick, true);
  };
  __proto._disableClick = function() {
    window.addEventListener("click", this._onPreventClick, true);
  };
  __proto._debounceScroll = function() {
    var _this = this;
    if (!this._scrollTimer) {
      this.trigger("beginScroll");
    }
    window.clearTimeout(this._scrollTimer);
    this._scrollTimer = window.setTimeout(function() {
      _this._scrollTimer = 0;
      _this.trigger("finishScroll", {
        isDragScroll: _this._isDragScroll,
        isTrusted: _this._isDragScroll || !_this._isAnimation
      });
      _this._isDragScroll = false;
      _this._isAnimation = false;
    }, this._options.scrollDebounce);
  };
  __decorate2([Reactive("isReachStart")], Conveyer2.prototype, "_isReachStart", void 0);
  __decorate2([Reactive("isReachEnd")], Conveyer2.prototype, "_isReachEnd", void 0);
  __decorate2([Reactive("scrollPos")], Conveyer2.prototype, "_pos", void 0);
  Conveyer2 = __decorate2([ReactiveSubscribe], Conveyer2);
  return Conveyer2;
}(component_esm_default);
var CONVEYER_METHODS = ["update", "findElement", "findItem", "scrollBy", "scrollTo", "scrollIntoView", "setItems", "updateContainer", "updateItems", "init"];
var CONVEYER_EVENTS = ["reachStart", "reachEnd", "leaveStart", "leaveEnd", "beginScroll", "finishScroll"];
var REACTIVE_CONVEYER = {
  methods: CONVEYER_METHODS,
  events: CONVEYER_EVENTS,
  created: function(data) {
    return new Conveyer(data.container, __assign2(__assign2({}, data.props), {
      autoInit: false
    }));
  },
  init: function(instance, data) {
    if (data.props.autoInit !== false) {
      instance.init();
    }
  },
  on: function(instance, name, callback) {
    instance.on(name, callback);
  },
  off: function(instance, name, callback) {
    instance.off(name, callback);
  },
  destroy: function(instance) {
    instance.destroy();
  }
};
var conveyer_esm_default = Conveyer;
export {
  CONVEYER_EVENTS,
  CONVEYER_METHODS,
  REACTIVE_CONVEYER,
  conveyer_esm_default as default
};
/*! Bundled license information:

@egjs/axes/dist/axes.esm.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@egjs_conveyer.js.map
