import {
  autoUpdate,
  computePosition
} from "./chunk-OE4UF7ZZ.js";
import {
  flip,
  offset,
  shift
} from "./chunk-AVJCZAFY.js";
import "./chunk-PIFSV4DX.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  compute_slots,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  space,
  stop_propagation,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-UJLIVLOQ.js";

// node_modules/svelte-floating-ui/index.js
function createFloatingActions(initOptions) {
  let referenceElement;
  let floatingElement;
  const defaultOptions = {
    autoUpdate: true
  };
  let options = initOptions;
  const getOptions = (mixin) => {
    return { ...defaultOptions, ...initOptions || {}, ...mixin || {} };
  };
  const updatePosition = (updateOptions) => {
    if (referenceElement && floatingElement) {
      options = getOptions(updateOptions);
      computePosition(referenceElement, floatingElement, options).then((v) => {
        Object.assign(floatingElement.style, {
          position: v.strategy,
          left: `${v.x}px`,
          top: `${v.y}px`
        });
        (options == null ? void 0 : options.onComputed) && options.onComputed(v);
      });
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceElement = node;
      updatePosition();
    }
  };
  const contentAction = (node, contentOptions) => {
    let autoUpdateDestroy;
    floatingElement = node;
    options = getOptions(contentOptions);
    setTimeout(() => updatePosition(contentOptions), 0);
    updatePosition(contentOptions);
    const destroyAutoUpdate = () => {
      if (autoUpdateDestroy) {
        autoUpdateDestroy();
        autoUpdateDestroy = void 0;
      }
    };
    const initAutoUpdate = ({ autoUpdate: autoUpdate2 } = options || {}) => {
      destroyAutoUpdate();
      if (autoUpdate2 !== false) {
        return autoUpdate(referenceElement, floatingElement, () => updatePosition(options), autoUpdate2 === true ? {} : autoUpdate2);
      }
      return;
    };
    autoUpdateDestroy = initAutoUpdate();
    return {
      update(contentOptions2) {
        updatePosition(contentOptions2);
        autoUpdateDestroy = initAutoUpdate(contentOptions2);
      },
      destroy() {
        destroyAutoUpdate();
      }
    };
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceElement === void 0) {
        referenceElement = $node;
        updatePosition();
      } else {
        Object.assign(referenceElement, $node);
        updatePosition();
      }
    });
    onDestroy(unsubscribe);
  };
  return [
    referenceAction,
    contentAction,
    updatePosition
  ];
}

// node_modules/svelte-select/filter.js
function filter({
  loadOptions,
  filterText,
  items,
  multiple,
  value,
  itemId,
  groupBy,
  filterSelectedItems,
  itemFilter,
  convertStringItemsToObjects: convertStringItemsToObjects2,
  filterGroupedItems,
  label
}) {
  if (items && loadOptions)
    return items;
  if (!items)
    return [];
  if (items && items.length > 0 && typeof items[0] !== "object") {
    items = convertStringItemsToObjects2(items);
  }
  let filterResults = items.filter((item) => {
    let matchesFilter = itemFilter(item[label], filterText, item);
    if (matchesFilter && multiple && (value == null ? void 0 : value.length)) {
      matchesFilter = !value.some((x) => {
        return filterSelectedItems ? x[itemId] === item[itemId] : false;
      });
    }
    return matchesFilter;
  });
  if (groupBy) {
    filterResults = filterGroupedItems(filterResults);
  }
  return filterResults;
}

// node_modules/svelte-select/get-items.js
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects: convertStringItemsToObjects2, filterText }) {
  let res = await loadOptions(filterText).catch((err) => {
    console.warn("svelte-select loadOptions error :>> ", err);
    dispatch("error", { type: "loadOptions", details: err });
  });
  if (res && !res.cancelled) {
    if (res) {
      if (res && res.length > 0 && typeof res[0] !== "object") {
        res = convertStringItemsToObjects2(res);
      }
      dispatch("loaded", { items: res });
    } else {
      res = [];
    }
    return {
      filteredItems: res,
      loading: false,
      focused: true,
      listOpen: true
    };
  }
}

// node_modules/svelte-select/ChevronIcon.svelte
var file = "node_modules\\svelte-select\\ChevronIcon.svelte";
function add_css(target) {
  append_styles(target, "svelte-qbd276", "svg.svelte-qbd276{width:var(--chevron-icon-width, 20px);height:var(--chevron-icon-width, 20px);color:var(--chevron-icon-colour, currentColor)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hldnJvbkljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdCRSxpQkFBSSxDQUNBLEtBQUssQ0FBRSxJQUFJLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUN0QyxNQUFNLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FDdkMsS0FBSyxDQUFFLElBQUkscUJBQXFCLENBQUMsYUFBYSxDQUNsRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaGV2cm9uSWNvbi5zdmVsdGUiXX0= */");
}
function create_fragment(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        focusable: true,
        "aria-hidden": true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      add_location(path, file, 6, 4, 114);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "class", "svelte-qbd276");
      add_location(svg, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChevronIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var ChevronIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronIcon",
      options,
      id: create_fragment.name
    });
  }
};
var ChevronIcon_default = ChevronIcon;

// node_modules/svelte-select/ClearIcon.svelte
var file2 = "node_modules\\svelte-select\\ClearIcon.svelte";
function add_css2(target) {
  append_styles(target, "svelte-whdbu1", "svg.svelte-whdbu1{width:var(--clear-icon-width, 20px);height:var(--clear-icon-width, 20px);color:var(--clear-icon-color, currentColor)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xlYXJJY29uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnQkksaUJBQUksQ0FDQSxLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FDcEMsTUFBTSxDQUFFLElBQUksa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQ3JDLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLGFBQWEsQ0FDL0MiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ2xlYXJJY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment2(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        focusable: true,
        "aria-hidden": true,
        role: true,
        class: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { fill: true, d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      add_location(path, file2, 8, 4, 141);
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "height", "100%");
      attr_dev(svg, "viewBox", "-2 -2 50 50");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "role", "presentation");
      attr_dev(svg, "class", "svelte-whdbu1");
      add_location(svg, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClearIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var ClearIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClearIcon",
      options,
      id: create_fragment2.name
    });
  }
};
var ClearIcon_default = ClearIcon;

// node_modules/svelte-select/LoadingIcon.svelte
var file3 = "node_modules\\svelte-select\\LoadingIcon.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1p3nqvd", ".loading.svelte-1p3nqvd{width:var(--spinner-width, 20px);height:var(--spinner-height, 20px);color:var(--spinner-color, var(--icons-color));animation:svelte-1p3nqvd-rotate 0.75s linear infinite;transform-origin:center center;transform:none}.circle_path.svelte-1p3nqvd{stroke-dasharray:90;stroke-linecap:round}@keyframes svelte-1p3nqvd-rotate{100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZ0ljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWFJLHVCQUFTLENBQ0wsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUNqQyxNQUFNLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FDbkMsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLG1CQUFtQixDQUFDLENBQy9DLFNBQVMsQ0FBRSxxQkFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUN2QyxnQkFBZ0IsQ0FBRSxNQUFNLENBQUMsTUFBTSxDQUMvQixTQUFTLENBQUUsSUFDZixDQUVBLDJCQUFhLENBQ1QsZ0JBQWdCLENBQUUsRUFBRSxDQUNwQixjQUFjLENBQUUsS0FDcEIsQ0FFQSxXQUFXLHFCQUFPLENBQ2QsSUFBSyxDQUNELFNBQVMsQ0FBRSxPQUFPLE1BQU0sQ0FDNUIsQ0FDSiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMb2FkaW5nSWNvbi5zdmVsdGUiXX0= */");
}
function create_fragment3(ctx) {
  let svg;
  let circle;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", {
        class: true,
        cx: true,
        cy: true,
        r: true,
        fill: true,
        stroke: true,
        "stroke-width": true,
        "stroke-miterlimit": true
      });
      children(circle).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "class", "circle_path svelte-1p3nqvd");
      attr_dev(circle, "cx", "50");
      attr_dev(circle, "cy", "50");
      attr_dev(circle, "r", "20");
      attr_dev(circle, "fill", "none");
      attr_dev(circle, "stroke", "currentColor");
      attr_dev(circle, "stroke-width", "5");
      attr_dev(circle, "stroke-miterlimit", "10");
      add_location(circle, file3, 1, 4, 48);
      attr_dev(svg, "class", "loading svelte-1p3nqvd");
      attr_dev(svg, "viewBox", "25 25 50 50");
      add_location(svg, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LoadingIcon", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LoadingIcon> was created with unknown prop '${key}'`);
  });
  return [];
}
var LoadingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LoadingIcon",
      options,
      id: create_fragment3.name
    });
  }
};
var LoadingIcon_default = LoadingIcon;

// node_modules/svelte-select/Select.svelte
var { Object: Object_1 } = globals;
var file4 = "node_modules\\svelte-select\\Select.svelte";
function add_css4(target) {
  append_styles(target, "svelte-apvs86", ".svelte-select.svelte-apvs86.svelte-apvs86.svelte-apvs86{--borderRadius:var(--border-radius);--clearSelectColor:var(--clear-select-color);--clearSelectWidth:var(--clear-select-width);--disabledBackground:var(--disabled-background);--disabledBorderColor:var(--disabled-border-color);--disabledColor:var(--disabled-color);--disabledPlaceholderColor:var(--disabled-placeholder-color);--disabledPlaceholderOpacity:var(--disabled-placeholder-opacity);--errorBackground:var(--error-background);--errorBorder:var(--error-border);--groupItemPaddingLeft:var(--group-item-padding-left);--groupTitleColor:var(--group-title-color);--groupTitleFontSize:var(--group-title-font-size);--groupTitleFontWeight:var(--group-title-font-weight);--groupTitlePadding:var(--group-title-padding);--groupTitleTextTransform:var(--group-title-text-transform);--indicatorColor:var(--chevron-color);--indicatorHeight:var(--chevron-height);--indicatorWidth:var(--chevron-width);--inputColor:var(--input-color);--inputLeft:var(--input-left);--inputLetterSpacing:var(--input-letter-spacing);--inputMargin:var(--input-margin);--inputPadding:var(--input-padding);--itemActiveBackground:var(--item-active-background);--itemColor:var(--item-color);--itemFirstBorderRadius:var(--item-first-border-radius);--itemHoverBG:var(--item-hover-bg);--itemHoverColor:var(--item-hover-color);--itemIsActiveBG:var(--item-is-active-bg);--itemIsActiveColor:var(--item-is-active-color);--itemIsNotSelectableColor:var(--item-is-not-selectable-color);--itemPadding:var(--item-padding);--listBackground:var(--list-background);--listBorder:var(--list-border);--listBorderRadius:var(--list-border-radius);--listEmptyColor:var(--list-empty-color);--listEmptyPadding:var(--list-empty-padding);--listEmptyTextAlign:var(--list-empty-text-align);--listMaxHeight:var(--list-max-height);--listPosition:var(--list-position);--listShadow:var(--list-shadow);--listZIndex:var(--list-z-index);--multiItemBG:var(--multi-item-bg);--multiItemBorderRadius:var(--multi-item-border-radius);--multiItemDisabledHoverBg:var(--multi-item-disabled-hover-bg);--multiItemDisabledHoverColor:var(--multi-item-disabled-hover-color);--multiItemHeight:var(--multi-item-height);--multiItemMargin:var(--multi-item-margin);--multiItemPadding:var(--multi-item-padding);--multiSelectInputMargin:var(--multi-select-input-margin);--multiSelectInputPadding:var(--multi-select-input-padding);--multiSelectPadding:var(--multi-select-padding);--placeholderColor:var(--placeholder-color);--placeholderOpacity:var(--placeholder-opacity);--selectedItemPadding:var(--selected-item-padding);--spinnerColor:var(--spinner-color);--spinnerHeight:var(--spinner-height);--spinnerWidth:var(--spinner-width);--internal-padding:0 0 0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--border-radius, 6px);min-height:var(--height, 42px);position:relative;display:flex;align-items:stretch;padding:var(--padding, var(--internal-padding));background:var(--background, #fff);margin:var(--margin, 0);width:var(--width, 100%);font-size:var(--font-size, 16px);max-height:var(--max-height)}.svelte-apvs86.svelte-apvs86.svelte-apvs86{box-sizing:var(--box-sizing, border-box)}.svelte-select.svelte-apvs86.svelte-apvs86.svelte-apvs86:hover{border:var(--border-hover, 1px solid #b2b8bf)}.value-container.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;flex:1 1 0%;flex-wrap:wrap;align-items:center;gap:5px 10px;padding:var(--value-container-padding, 5px 0);position:relative;overflow:var(--value-container-overflow, hidden);align-self:stretch}.prepend.svelte-apvs86.svelte-apvs86.svelte-apvs86,.indicators.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;flex-shrink:0;align-items:center}.indicators.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:var(--indicators-position);top:var(--indicators-top);right:var(--indicators-right);bottom:var(--indicators-bottom)}input.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:absolute;cursor:default;border:none;color:var(--input-color, var(--item-color));padding:var(--input-padding, 0);letter-spacing:var(--input-letter-spacing, inherit);margin:var(--input-margin, 0);min-width:10px;top:0;right:0;bottom:0;left:0;background:transparent;font-size:var(--font-size, 16px)}.svelte-apvs86:not(.multi)>.value-container.svelte-apvs86>input.svelte-apvs86{width:100%;height:100%}input.svelte-apvs86.svelte-apvs86.svelte-apvs86::placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:none}.svelte-select.focused.svelte-apvs86.svelte-apvs86.svelte-apvs86{border:var(--border-focused, 1px solid #006fe8);border-radius:var(--border-radius-focused, var(--border-radius, 6px))}.disabled.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--disabled-background, #ebedef);border-color:var(--disabled-border-color, #ebedef);color:var(--disabled-color, #c1c6cc)}.disabled.svelte-apvs86 input.svelte-apvs86.svelte-apvs86::placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{position:relative;overflow:var(--selected-item-overflow, hidden);padding:var(--selected-item-padding, 0 20px 0 0);text-overflow:ellipsis;white-space:nowrap;color:var(--selected-item-color, inherit);font-size:var(--font-size, 16px)}.multi.svelte-apvs86 .selected-item.svelte-apvs86.svelte-apvs86{position:absolute;line-height:var(--height, 42px);height:var(--height, 42px)}.selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:none}.hide-selected-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0}.icon.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;align-items:center;justify-content:center}.clear-select.svelte-apvs86.svelte-apvs86.svelte-apvs86{all:unset;display:flex;align-items:center;justify-content:center;width:var(--clear-select-width, 40px);height:var(--clear-select-height, 100%);color:var(--clear-select-color, var(--icons-color));margin:var(--clear-select-margin, 0);pointer-events:all;flex-shrink:0}.clear-select.svelte-apvs86.svelte-apvs86.svelte-apvs86:focus{outline:var(--clear-select-focus-outline, 1px solid #006fe8)}.loading.svelte-apvs86.svelte-apvs86.svelte-apvs86{width:var(--loading-width, 40px);height:var(--loading-height);color:var(--loading-color, var(--icons-color));margin:var(--loading--margin, 0);flex-shrink:0}.chevron.svelte-apvs86.svelte-apvs86.svelte-apvs86{width:var(--chevron-width, 40px);height:var(--chevron-height, 40px);background:var(--chevron-background, transparent);pointer-events:var(--chevron-pointer-events, none);color:var(--chevron-color, var(--icons-color));border:var(--chevron-border, 0 0 0 1px solid #d8dbdf);flex-shrink:0}.multi.svelte-apvs86.svelte-apvs86.svelte-apvs86{padding:var(--multi-select-padding, var(--internal-padding))}.multi.svelte-apvs86 input.svelte-apvs86.svelte-apvs86{padding:var(--multi-select-input-padding, 0);position:relative;margin:var(--multi-select-input-margin, 5px 0);flex:1 1 40px}.svelte-select.error.svelte-apvs86.svelte-apvs86.svelte-apvs86{border:var(--error-border, 1px solid #ff2d55);background:var(--error-background, #fff)}.a11y-text.svelte-apvs86.svelte-apvs86.svelte-apvs86{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.multi-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--multi-item-bg, #ebedef);margin:var(--multi-item-margin, 0);outline:var(--multi-item-outline, 1px solid #ddd);border-radius:var(--multi-item-border-radius, 4px);height:var(--multi-item-height, 25px);line-height:var(--multi-item-height, 25px);display:flex;cursor:default;padding:var(--multi-item-padding, 0 5px);overflow:hidden;gap:var(--multi-item-gap, 4px);outline-offset:-1px;max-width:var(--multi-max-width, none);color:var(--multi-item-color, var(--item-color))}.multi-item.disabled.svelte-apvs86.svelte-apvs86.svelte-apvs86:hover{background:var(--multi-item-disabled-hover-bg, #ebedef);color:var(--multi-item-disabled-hover-color, #c1c6cc)}.multi-item-text.svelte-apvs86.svelte-apvs86.svelte-apvs86{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multi-item-clear.svelte-apvs86.svelte-apvs86.svelte-apvs86{display:flex;align-items:center;justify-content:center;--clear-icon-color:var(--multi-item-clear-icon-color, #000)}.multi-item.active.svelte-apvs86.svelte-apvs86.svelte-apvs86{outline:var(--multi-item-active-outline, 1px solid #006fe8)}.svelte-select-list.svelte-apvs86.svelte-apvs86.svelte-apvs86{box-shadow:var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--list-border-radius, 4px);max-height:var(--list-max-height, 252px);overflow-y:auto;background:var(--list-background, #fff);position:var(--list-position, absolute);z-index:var(--list-z-index, 2);border:var(--list-border)}.prefloat.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0;pointer-events:none}.list-group-title.svelte-apvs86.svelte-apvs86.svelte-apvs86{color:var(--group-title-color, #8f8f8f);cursor:default;font-size:var(--group-title-font-size, 16px);font-weight:var(--group-title-font-weight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--group-title-padding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--group-title-text-transform, uppercase)}.empty.svelte-apvs86.svelte-apvs86.svelte-apvs86{text-align:var(--list-empty-text-align, center);padding:var(--list-empty-padding, 20px 0);color:var(--list-empty-color, #78848f)}.item.svelte-apvs86.svelte-apvs86.svelte-apvs86{cursor:default;height:var(--item-height, var(--height, 42px));line-height:var(--item-line-height, var(--height, 42px));padding:var(--item-padding, 0 20px);color:var(--item-color, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;transition:var(--item-transition, all 0.2s);align-items:center;width:100%}.item.group-item.svelte-apvs86.svelte-apvs86.svelte-apvs86{padding-left:var(--group-item-padding-left, 40px)}.item.svelte-apvs86.svelte-apvs86.svelte-apvs86:active{background:var(--item-active-background, #b9daff)}.item.active.svelte-apvs86.svelte-apvs86.svelte-apvs86{background:var(--item-is-active-bg, #007aff);color:var(--item-is-active-color, #fff)}.item.first.svelte-apvs86.svelte-apvs86.svelte-apvs86{border-radius:var(--item-first-border-radius, 4px 4px 0 0)}.item.hover.svelte-apvs86.svelte-apvs86.svelte-apvs86:not(.active){background:var(--item-hover-bg, #e7f2ff);color:var(--item-hover-color, inherit)}.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.hover.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.active.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86,.item.not-selectable.svelte-apvs86.svelte-apvs86.svelte-apvs86:active{color:var(--item-is-not-selectable-color, #999);background:transparent}.required.svelte-apvs86.svelte-apvs86.svelte-apvs86{opacity:0;z-index:-1;position:absolute;top:0;left:0;bottom:0;right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sQ0FBQyxDQUMxQyxLQUFLLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQzFDLENBRUEsK0NBQU0sQ0FDRixNQUFNLENBQUUsT0FBTyxDQUNmLE1BQU0sQ0FBRSxJQUFJLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUMvQyxXQUFXLENBQUUsSUFBSSxrQkFBa0IsQ0FBQyxvQkFBb0IsQ0FBQyxDQUN6RCxPQUFPLENBQUUsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQ3BDLEtBQUssQ0FBRSxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FDakMsYUFBYSxDQUFFLFFBQVEsQ0FDdkIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsVUFBVSxDQUFFLElBQUksaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQzVDLFdBQVcsQ0FBRSxNQUFNLENBQ25CLEtBQUssQ0FBRSxJQUNYLENBRUEsS0FBSyxxREFBWSxDQUNiLFlBQVksQ0FBRSxJQUFJLHlCQUF5QixDQUFDLEtBQUssQ0FDckQsQ0FFQSwrQ0FBSyxPQUFRLENBQ1QsVUFBVSxDQUFFLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUNyRCxDQUVBLEtBQUssaURBQVEsQ0FDVCxVQUFVLENBQUUsSUFBSSxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FDN0MsS0FBSyxDQUFFLElBQUksc0JBQXNCLENBQUMsS0FBSyxDQUMzQyxDQUVBLEtBQUssZ0RBQU8sQ0FDUixhQUFhLENBQUUsSUFBSSwwQkFBMEIsQ0FBQyxZQUFZLENBQzlELENBRUEsS0FBSyxnREFBTSxLQUFLLE9BQU8sQ0FBRSxDQUNyQixVQUFVLENBQUUsSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLENBQ3pDLEtBQUssQ0FBRSxJQUFJLGtCQUFrQixDQUFDLFFBQVEsQ0FDMUMsQ0FFQSxLQUFLLHlEQUFlLENBQ3BCLEtBQUssTUFBTSxLQUFLLHlEQUFlLENBQy9CLEtBQUssT0FBTyxLQUFLLHlEQUFlLENBQ2hDLEtBQUsseURBQWUsT0FBUSxDQUN4QixLQUFLLENBQUUsSUFBSSw4QkFBOEIsQ0FBQyxLQUFLLENBQUMsQ0FDaEQsVUFBVSxDQUFFLFdBQ2hCLENBRUEsbURBQVUsQ0FDTixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxFQUFFLENBQ1gsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLE1BQU0sQ0FBRSxDQUFDLENBQ1QsS0FBSyxDQUFFLENBQ1giLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdfQ== */");
}
var get_required_slot_changes = (dirty) => ({ value: dirty[0] & /*value*/
8 });
var get_required_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[3]
) });
var get_chevron_icon_slot_changes = (dirty) => ({ listOpen: dirty[0] & /*listOpen*/
64 });
var get_chevron_icon_slot_context = (ctx) => ({ listOpen: (
  /*listOpen*/
  ctx[6]
) });
var get_clear_icon_slot_changes = (dirty) => ({});
var get_clear_icon_slot_context = (ctx) => ({});
var get_loading_icon_slot_changes = (dirty) => ({});
var get_loading_icon_slot_context = (ctx) => ({});
var get_selection_slot_changes_1 = (dirty) => ({ selection: dirty[0] & /*value*/
8 });
var get_selection_slot_context_1 = (ctx) => ({ selection: (
  /*value*/
  ctx[3]
) });
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[125] = list[i];
  child_ctx[127] = i;
  return child_ctx;
}
var get_multi_clear_icon_slot_changes = (dirty) => ({});
var get_multi_clear_icon_slot_context = (ctx) => ({});
var get_selection_slot_changes = (dirty) => ({ selection: dirty[0] & /*value*/
8 });
var get_selection_slot_context = (ctx) => ({
  selection: (
    /*item*/
    ctx[125]
  ),
  index: (
    /*i*/
    ctx[127]
  )
});
var get_prepend_slot_changes = (dirty) => ({});
var get_prepend_slot_context = (ctx) => ({});
var get_list_append_slot_changes = (dirty) => ({});
var get_list_append_slot_context = (ctx) => ({});
var get_empty_slot_changes = (dirty) => ({});
var get_empty_slot_context = (ctx) => ({});
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[125] = list[i];
  child_ctx[127] = i;
  return child_ctx;
}
var get_item_slot_changes = (dirty) => ({
  item: dirty[0] & /*filteredItems*/
  16777216
});
var get_item_slot_context = (ctx) => ({
  item: (
    /*item*/
    ctx[125]
  ),
  index: (
    /*i*/
    ctx[127]
  )
});
var get_list_slot_changes = (dirty) => ({
  filteredItems: dirty[0] & /*filteredItems*/
  16777216
});
var get_list_slot_context = (ctx) => ({ filteredItems: (
  /*filteredItems*/
  ctx[24]
) });
var get_list_prepend_slot_changes = (dirty) => ({});
var get_list_prepend_slot_context = (ctx) => ({});
function create_if_block_8(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let floatingContent_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[50]["list-prepend"] && create_if_block_13(ctx)
  );
  const if_block_creators = [create_if_block_10, create_if_block_11, create_if_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[50].list
    )
      return 0;
    if (
      /*filteredItems*/
      ctx2[24].length > 0
    )
      return 1;
    if (!/*hideEmptyState*/
    ctx2[19])
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block2 = (
    /*$$slots*/
    ctx[50]["list-append"] && create_if_block_9(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-select-list svelte-apvs86");
      toggle_class(
        div,
        "prefloat",
        /*prefloat*/
        ctx[28]
      );
      add_location(div, file4, 682, 8, 20859);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      ctx[90](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(floatingContent_action = /*floatingContent*/
          ctx[49].call(null, div)),
          listen_dev(
            div,
            "scroll",
            /*handleListScroll*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "pointerup", stop_propagation(prevent_default(
            /*pointerup_handler*/
            ctx[85]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[50]["list-prepend"]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          524288) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        } else {
          if_block1 = null;
        }
      }
      if (
        /*$$slots*/
        ctx2[50]["list-append"]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          524288) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*prefloat*/
      268435456) {
        toggle_class(
          div,
          "prefloat",
          /*prefloat*/
          ctx2[28]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block2)
        if_block2.d();
      ctx[90](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(682:4) {#if listOpen}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let current;
  const list_prepend_slot_template = (
    /*#slots*/
    ctx[82]["list-prepend"]
  );
  const list_prepend_slot = create_slot(
    list_prepend_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_list_prepend_slot_context
  );
  const block = {
    c: function create() {
      if (list_prepend_slot)
        list_prepend_slot.c();
    },
    l: function claim(nodes) {
      if (list_prepend_slot)
        list_prepend_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (list_prepend_slot) {
        list_prepend_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_prepend_slot) {
        if (list_prepend_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            list_prepend_slot,
            list_prepend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              list_prepend_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_list_prepend_slot_changes
            ),
            get_list_prepend_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_prepend_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_prepend_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (list_prepend_slot)
        list_prepend_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(690:12) {#if $$slots['list-prepend']}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[82].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_empty_slot_context
  );
  const empty_slot_or_fallback = empty_slot || fallback_block_8(ctx);
  const block = {
    c: function create() {
      if (empty_slot_or_fallback)
        empty_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (empty_slot_or_fallback)
        empty_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (empty_slot_or_fallback) {
        empty_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_empty_slot_changes
            ),
            get_empty_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(empty_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(empty_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (empty_slot_or_fallback)
        empty_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(717:38) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = (
    /*filteredItems*/
    ctx[24]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/
      1627402376 | dirty[1] & /*handleHover, handleItemClick, isItemActive*/
      28672 | dirty[2] & /*$$scope*/
      524288) {
        each_value_1 = /*filteredItems*/
        ctx2[24];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(692:47) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[82].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_list_slot_context
  );
  const block = {
    c: function create() {
      if (list_slot)
        list_slot.c();
    },
    l: function claim(nodes) {
      if (list_slot)
        list_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (list_slot) {
        list_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_list_slot_changes
            ),
            get_list_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (list_slot)
        list_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(691:12) {#if $$slots.list}",
    ctx
  });
  return block;
}
function fallback_block_8(ctx) {
  let div;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text("No options");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, "No options");
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "empty svelte-apvs86");
      add_location(div, file4, 718, 20, 22697);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_8.name,
    type: "fallback",
    source: "(718:35)                      ",
    ctx
  });
  return block;
}
function fallback_block_7(ctx) {
  var _a;
  let t_value = (
    /*item*/
    ((_a = ctx[125]) == null ? void 0 : _a[
      /*label*/
      ctx[12]
    ]) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*filteredItems, label*/
      16781312 && t_value !== (t_value = /*item*/
      ((_a2 = ctx2[125]) == null ? void 0 : _a2[
        /*label*/
        ctx2[12]
      ]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_7.name,
    type: "fallback",
    source: "(711:63)                                  ",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let div1;
  let div0;
  let activeScroll_action;
  let hoverScroll_action;
  let t;
  let current;
  let mounted;
  let dispose;
  const item_slot_template = (
    /*#slots*/
    ctx[82].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_item_slot_context
  );
  const item_slot_or_fallback = item_slot || fallback_block_7(ctx);
  function mouseover_handler() {
    return (
      /*mouseover_handler*/
      ctx[87](
        /*i*/
        ctx[127]
      )
    );
  }
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[88](
        /*i*/
        ctx[127]
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[89](
        /*item*/
        ctx[125],
        /*i*/
        ctx[127]
      )
    );
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (item_slot_or_fallback)
        item_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, tabindex: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (item_slot_or_fallback)
        item_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(div0, "class", "item svelte-apvs86");
      toggle_class(
        div0,
        "list-group-title",
        /*item*/
        ctx[125].groupHeader
      );
      toggle_class(
        div0,
        "active",
        /*isItemActive*/
        ctx[45](
          /*item*/
          ctx[125],
          /*value*/
          ctx[3],
          /*itemId*/
          ctx[13]
        )
      );
      toggle_class(div0, "first", isItemFirst(
        /*i*/
        ctx[127]
      ));
      toggle_class(
        div0,
        "hover",
        /*hoverItemIndex*/
        ctx[7] === /*i*/
        ctx[127]
      );
      toggle_class(
        div0,
        "group-item",
        /*item*/
        ctx[125].groupItem
      );
      toggle_class(
        div0,
        "not-selectable",
        /*item*/
        ((_a = ctx[125]) == null ? void 0 : _a.selectable) === false
      );
      add_location(div0, file4, 700, 24, 21725);
      attr_dev(div1, "class", "list-item svelte-apvs86");
      attr_dev(div1, "tabindex", "-1");
      add_location(div1, file4, 693, 20, 21347);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (item_slot_or_fallback) {
        item_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(activeScroll_action = /*activeScroll*/
          ctx[46].call(null, div0, {
            scroll: (
              /*isItemActive*/
              ctx[45](
                /*item*/
                ctx[125],
                /*value*/
                ctx[3],
                /*itemId*/
                ctx[13]
              )
            ),
            listDom: (
              /*listDom*/
              ctx[30]
            )
          })),
          action_destroyer(hoverScroll_action = /*hoverScroll*/
          ctx[47].call(null, div0, {
            scroll: (
              /*scrollToHoverItem*/
              ctx[29] === /*i*/
              ctx[127]
            ),
            listDom: (
              /*listDom*/
              ctx[30]
            )
          })),
          listen_dev(div1, "mouseover", mouseover_handler, false, false, false, false),
          listen_dev(div1, "focus", focus_handler, false, false, false, false),
          listen_dev(div1, "click", stop_propagation(click_handler), false, false, true, false),
          listen_dev(div1, "keydown", stop_propagation(prevent_default(
            /*keydown_handler*/
            ctx[86]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[81]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[81],
              dirty,
              get_item_slot_changes
            ),
            get_item_slot_context
          );
        }
      } else {
        if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[0] & /*filteredItems, label*/
        16781312)) {
          item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (activeScroll_action && is_function(activeScroll_action.update) && dirty[0] & /*filteredItems, value, itemId, listDom*/
      1090527240)
        activeScroll_action.update.call(null, {
          scroll: (
            /*isItemActive*/
            ctx[45](
              /*item*/
              ctx[125],
              /*value*/
              ctx[3],
              /*itemId*/
              ctx[13]
            )
          ),
          listDom: (
            /*listDom*/
            ctx[30]
          )
        });
      if (hoverScroll_action && is_function(hoverScroll_action.update) && dirty[0] & /*scrollToHoverItem, listDom*/
      1610612736)
        hoverScroll_action.update.call(null, {
          scroll: (
            /*scrollToHoverItem*/
            ctx[29] === /*i*/
            ctx[127]
          ),
          listDom: (
            /*listDom*/
            ctx[30]
          )
        });
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "list-group-title",
          /*item*/
          ctx[125].groupHeader
        );
      }
      if (!current || dirty[0] & /*filteredItems, value, itemId*/
      16785416 | dirty[1] & /*isItemActive*/
      16384) {
        toggle_class(
          div0,
          "active",
          /*isItemActive*/
          ctx[45](
            /*item*/
            ctx[125],
            /*value*/
            ctx[3],
            /*itemId*/
            ctx[13]
          )
        );
      }
      if (!current || dirty[0] & /*hoverItemIndex*/
      128) {
        toggle_class(
          div0,
          "hover",
          /*hoverItemIndex*/
          ctx[7] === /*i*/
          ctx[127]
        );
      }
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "group-item",
          /*item*/
          ctx[125].groupItem
        );
      }
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "not-selectable",
          /*item*/
          ((_a = ctx[125]) == null ? void 0 : _a.selectable) === false
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (item_slot_or_fallback)
        item_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(693:16) {#each filteredItems as item, i}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let current;
  const list_append_slot_template = (
    /*#slots*/
    ctx[82]["list-append"]
  );
  const list_append_slot = create_slot(
    list_append_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_list_append_slot_context
  );
  const block = {
    c: function create() {
      if (list_append_slot)
        list_append_slot.c();
    },
    l: function claim(nodes) {
      if (list_append_slot)
        list_append_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (list_append_slot) {
        list_append_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_append_slot) {
        if (list_append_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            list_append_slot,
            list_append_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              list_append_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_list_append_slot_changes
            ),
            get_list_append_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_append_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_append_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (list_append_slot)
        list_append_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(722:12) {#if $$slots['list-append']}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(
        /*ariaSelection*/
        ctx[32]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*ariaContext*/
        ctx[31]
      );
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { id: true, class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*ariaSelection*/
        ctx[32]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { id: true, class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*ariaContext*/
        ctx[31]
      );
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "id", "aria-selection");
      attr_dev(span0, "class", "svelte-apvs86");
      add_location(span0, file4, 727, 12, 23006);
      attr_dev(span1, "id", "aria-context");
      attr_dev(span1, "class", "svelte-apvs86");
      add_location(span1, file4, 728, 12, 23067);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*ariaSelection*/
      2)
        set_data_dev(
          t0,
          /*ariaSelection*/
          ctx2[32]
        );
      if (dirty[1] & /*ariaContext*/
      1)
        set_data_dev(
          t2,
          /*ariaContext*/
          ctx2[31]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(727:8) {#if focused}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[9]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(740:8) {#if hasValue}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let div;
  let current;
  const selection_slot_template = (
    /*#slots*/
    ctx[82].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_selection_slot_context_1
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_6(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "selected-item svelte-apvs86");
      toggle_class(
        div,
        "hide-selected-item",
        /*hideSelectedItem*/
        ctx[35]
      );
      add_location(div, file4, 766, 16, 24540);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_selection_slot_changes_1
            ),
            get_selection_slot_context_1
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/
        4104)) {
          selection_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[1] & /*hideSelectedItem*/
      16) {
        toggle_class(
          div,
          "hide-selected-item",
          /*hideSelectedItem*/
          ctx2[35]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selection_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(766:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*value*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/
      67116040 | dirty[1] & /*handleMultiItemClear*/
      32 | dirty[2] & /*$$scope*/
      524288) {
        each_value = /*value*/
        ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(741:12) {#if multiple}",
    ctx
  });
  return block;
}
function fallback_block_6(ctx) {
  let t_value = (
    /*value*/
    ctx[3][
      /*label*/
      ctx[12]
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value, label*/
      4104 && t_value !== (t_value = /*value*/
      ctx2[3][
        /*label*/
        ctx2[12]
      ] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_6.name,
    type: "fallback",
    source: "(768:61)                          ",
    ctx
  });
  return block;
}
function fallback_block_5(ctx) {
  let t_value = (
    /*item*/
    ctx[125][
      /*label*/
      ctx[12]
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value, label*/
      4104 && t_value !== (t_value = /*item*/
      ctx2[125][
        /*label*/
        ctx2[12]
      ] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_5.name,
    type: "fallback",
    source: "(750:78)                                  ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const multi_clear_icon_slot_template = (
    /*#slots*/
    ctx[82]["multi-clear-icon"]
  );
  const multi_clear_icon_slot = create_slot(
    multi_clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_multi_clear_icon_slot_context
  );
  const multi_clear_icon_slot_or_fallback = multi_clear_icon_slot || fallback_block_4(ctx);
  function pointerup_handler_1() {
    return (
      /*pointerup_handler_1*/
      ctx[91](
        /*i*/
        ctx[127]
      )
    );
  }
  const block = {
    c: function create() {
      div = element("div");
      if (multi_clear_icon_slot_or_fallback)
        multi_clear_icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (multi_clear_icon_slot_or_fallback)
        multi_clear_icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "multi-item-clear svelte-apvs86");
      add_location(div, file4, 755, 28, 24064);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (multi_clear_icon_slot_or_fallback) {
        multi_clear_icon_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "pointerup", stop_propagation(prevent_default(pointerup_handler_1)), false, true, true, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (multi_clear_icon_slot) {
        if (multi_clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            multi_clear_icon_slot,
            multi_clear_icon_slot_template,
            ctx,
            /*$$scope*/
            ctx[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[81]
            ) : get_slot_changes(
              multi_clear_icon_slot_template,
              /*$$scope*/
              ctx[81],
              dirty,
              get_multi_clear_icon_slot_changes
            ),
            get_multi_clear_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(multi_clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(multi_clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (multi_clear_icon_slot_or_fallback)
        multi_clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(755:24) {#if !disabled && !multiFullItemClearable && ClearIcon}",
    ctx
  });
  return block;
}
function fallback_block_4(ctx) {
  let clearicon;
  let current;
  clearicon = new ClearIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(clearicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(clearicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(clearicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clearicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clearicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(clearicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(759:62)                                      ",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const selection_slot_template = (
    /*#slots*/
    ctx[82].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_selection_slot_context
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_5(ctx);
  let if_block = !/*disabled*/
  ctx[11] && !/*multiFullItemClearable*/
  ctx[10] && ClearIcon_default && create_if_block_6(ctx);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[92](
        /*i*/
        ctx[127]
      )
    );
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "multi-item-text svelte-apvs86");
      add_location(span, file4, 748, 24, 23731);
      attr_dev(div, "class", "multi-item svelte-apvs86");
      toggle_class(
        div,
        "active",
        /*activeValue*/
        ctx[26] === /*i*/
        ctx[127]
      );
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[11]
      );
      add_location(div, file4, 742, 20, 23384);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(span, null);
      }
      append_hydration_dev(div, t0);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", prevent_default(click_handler_1), false, true, false, false),
          listen_dev(div, "keydown", stop_propagation(prevent_default(
            /*keydown_handler_1*/
            ctx[84]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx,
            /*$$scope*/
            ctx[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[81]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx[81],
              dirty,
              get_selection_slot_changes
            ),
            get_selection_slot_context
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/
        4104)) {
          selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!/*disabled*/
      ctx[11] && !/*multiFullItemClearable*/
      ctx[10] && ClearIcon_default) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*disabled, multiFullItemClearable*/
          3072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*activeValue*/
      67108864) {
        toggle_class(
          div,
          "active",
          /*activeValue*/
          ctx[26] === /*i*/
          ctx[127]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      2048) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[11]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selection_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(742:16) {#each value as item, i}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let current;
  const loading_icon_slot_template = (
    /*#slots*/
    ctx[82]["loading-icon"]
  );
  const loading_icon_slot = create_slot(
    loading_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_loading_icon_slot_context
  );
  const loading_icon_slot_or_fallback = loading_icon_slot || fallback_block_3(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (loading_icon_slot_or_fallback)
        loading_icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div_nodes = children(div);
      if (loading_icon_slot_or_fallback)
        loading_icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "icon loading svelte-apvs86");
      attr_dev(div, "aria-hidden", "true");
      add_location(div, file4, 789, 12, 25229);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (loading_icon_slot_or_fallback) {
        loading_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_icon_slot) {
        if (loading_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            loading_icon_slot,
            loading_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              loading_icon_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_loading_icon_slot_changes
            ),
            get_loading_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loading_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (loading_icon_slot_or_fallback)
        loading_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(789:8) {#if loading}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let loadingicon;
  let current;
  loadingicon = new LoadingIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(loadingicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(loadingicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(loadingicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loadingicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loadingicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loadingicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(791:42)                      ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const clear_icon_slot_template = (
    /*#slots*/
    ctx[82]["clear-icon"]
  );
  const clear_icon_slot = create_slot(
    clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_clear_icon_slot_context
  );
  const clear_icon_slot_or_fallback = clear_icon_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "icon clear-select svelte-apvs86");
      add_location(button, file4, 797, 12, 25448);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (clear_icon_slot_or_fallback) {
        clear_icon_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "pointerup", stop_propagation(prevent_default(
          /*handleClear*/
          ctx[22]
        )), false, true, true, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (clear_icon_slot) {
        if (clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            clear_icon_slot,
            clear_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              clear_icon_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_clear_icon_slot_changes
            ),
            get_clear_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(797:8) {#if showClear}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let clearicon;
  let current;
  clearicon = new ClearIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(clearicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(clearicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(clearicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clearicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clearicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(clearicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(799:40)                      ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let current;
  const chevron_icon_slot_template = (
    /*#slots*/
    ctx[82]["chevron-icon"]
  );
  const chevron_icon_slot = create_slot(
    chevron_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_chevron_icon_slot_context
  );
  const chevron_icon_slot_or_fallback = chevron_icon_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (chevron_icon_slot_or_fallback)
        chevron_icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div_nodes = children(div);
      if (chevron_icon_slot_or_fallback)
        chevron_icon_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "icon chevron svelte-apvs86");
      attr_dev(div, "aria-hidden", "true");
      add_location(div, file4, 805, 12, 25715);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (chevron_icon_slot_or_fallback) {
        chevron_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (chevron_icon_slot) {
        if (chevron_icon_slot.p && (!current || dirty[0] & /*listOpen*/
        64 | dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            chevron_icon_slot,
            chevron_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              chevron_icon_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_chevron_icon_slot_changes
            ),
            get_chevron_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevron_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevron_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (chevron_icon_slot_or_fallback)
        chevron_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(805:8) {#if showChevron}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let chevronicon;
  let current;
  chevronicon = new ChevronIcon_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(chevronicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chevronicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chevronicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevronicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevronicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chevronicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(807:53)                      ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const required_slot_template = (
    /*#slots*/
    ctx[82].required
  );
  const required_slot = create_slot(
    required_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_required_slot_context
  );
  const required_slot_or_fallback = required_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (required_slot_or_fallback)
        required_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (required_slot_or_fallback)
        required_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (required_slot_or_fallback) {
        required_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (required_slot) {
        if (required_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            required_slot,
            required_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              required_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_required_slot_changes
            ),
            get_required_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(required_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(required_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (required_slot_or_fallback)
        required_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(816:4) {#if required && (!value || value.length === 0)}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let select;
  const block = {
    c: function create() {
      select = element("select");
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", {
        class: true,
        tabindex: true,
        "aria-hidden": true
      });
      children(select).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "class", "required svelte-apvs86");
      select.required = true;
      attr_dev(select, "tabindex", "-1");
      attr_dev(select, "aria-hidden", "true");
      add_location(select, file4, 817, 12, 26105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(817:38)              ",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div3;
  let t0;
  let span;
  let t1;
  let div0;
  let t2;
  let div1;
  let t3;
  let input0;
  let input0_readonly_value;
  let t4;
  let div2;
  let t5;
  let t6;
  let t7;
  let input1;
  let input1_value_value;
  let t8;
  let div3_class_value;
  let floatingRef_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*listOpen*/
    ctx[6] && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*focused*/
    ctx[2] && create_if_block_7(ctx)
  );
  const prepend_slot_template = (
    /*#slots*/
    ctx[82].prepend
  );
  const prepend_slot = create_slot(
    prepend_slot_template,
    ctx,
    /*$$scope*/
    ctx[81],
    get_prepend_slot_context
  );
  let if_block2 = (
    /*hasValue*/
    ctx[25] && create_if_block_4(ctx)
  );
  let input0_levels = [
    {
      readOnly: input0_readonly_value = !/*searchable*/
      ctx[17]
    },
    /*_inputAttributes*/
    ctx[27],
    { placeholder: (
      /*placeholderText*/
      ctx[33]
    ) },
    { style: (
      /*inputStyles*/
      ctx[18]
    ) },
    { disabled: (
      /*disabled*/
      ctx[11]
    ) }
  ];
  let input_data_1 = {};
  for (let i = 0; i < input0_levels.length; i += 1) {
    input_data_1 = assign(input_data_1, input0_levels[i]);
  }
  let if_block3 = (
    /*loading*/
    ctx[5] && create_if_block_3(ctx)
  );
  let if_block4 = (
    /*showClear*/
    ctx[34] && create_if_block_2(ctx)
  );
  let if_block5 = (
    /*showChevron*/
    ctx[20] && create_if_block_1(ctx)
  );
  let if_block6 = (
    /*required*/
    ctx[16] && (!/*value*/
    ctx[3] || /*value*/
    ctx[3].length === 0) && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (prepend_slot)
        prepend_slot.c();
      t2 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      t3 = space();
      input0 = element("input");
      t4 = space();
      div2 = element("div");
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      t7 = space();
      input1 = element("input");
      t8 = space();
      if (if_block6)
        if_block6.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      if (if_block0)
        if_block0.l(div3_nodes);
      t0 = claim_space(div3_nodes);
      span = claim_element(div3_nodes, "SPAN", {
        "aria-live": true,
        "aria-atomic": true,
        "aria-relevant": true,
        class: true
      });
      var span_nodes = children(span);
      if (if_block1)
        if_block1.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (prepend_slot)
        prepend_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block2)
        if_block2.l(div1_nodes);
      t3 = claim_space(div1_nodes);
      input0 = claim_element(div1_nodes, "INPUT", { placeholder: true, style: true });
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block3)
        if_block3.l(div2_nodes);
      t5 = claim_space(div2_nodes);
      if (if_block4)
        if_block4.l(div2_nodes);
      t6 = claim_space(div2_nodes);
      if (if_block5)
        if_block5.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      t7 = claim_space(div3_nodes);
      input1 = claim_element(div3_nodes, "INPUT", { name: true, type: true, class: true });
      t8 = claim_space(div3_nodes);
      if (if_block6)
        if_block6.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "aria-live", "polite");
      attr_dev(span, "aria-atomic", "false");
      attr_dev(span, "aria-relevant", "additions text");
      attr_dev(span, "class", "a11y-text svelte-apvs86");
      add_location(span, file4, 725, 4, 22877);
      attr_dev(div0, "class", "prepend svelte-apvs86");
      add_location(div0, file4, 734, 4, 23173);
      set_attributes(input0, input_data_1);
      toggle_class(input0, "svelte-apvs86", true);
      add_location(input0, file4, 774, 8, 24805);
      attr_dev(div1, "class", "value-container svelte-apvs86");
      add_location(div1, file4, 738, 4, 23243);
      attr_dev(div2, "class", "indicators svelte-apvs86");
      add_location(div2, file4, 787, 4, 25170);
      attr_dev(
        input1,
        "name",
        /*name*/
        ctx[8]
      );
      attr_dev(input1, "type", "hidden");
      input1.value = input1_value_value = /*value*/
      ctx[3] ? JSON.stringify(
        /*value*/
        ctx[3]
      ) : null;
      attr_dev(input1, "class", "svelte-apvs86");
      add_location(input1, file4, 813, 4, 25924);
      attr_dev(div3, "class", div3_class_value = "svelte-select " + /*containerClasses*/
      ctx[21] + " svelte-apvs86");
      attr_dev(
        div3,
        "style",
        /*containerStyles*/
        ctx[14]
      );
      toggle_class(
        div3,
        "multi",
        /*multiple*/
        ctx[9]
      );
      toggle_class(
        div3,
        "disabled",
        /*disabled*/
        ctx[11]
      );
      toggle_class(
        div3,
        "focused",
        /*focused*/
        ctx[2]
      );
      toggle_class(
        div3,
        "list-open",
        /*listOpen*/
        ctx[6]
      );
      toggle_class(
        div3,
        "show-chevron",
        /*showChevron*/
        ctx[20]
      );
      toggle_class(
        div3,
        "error",
        /*hasError*/
        ctx[15]
      );
      add_location(div3, file4, 668, 0, 20470);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      if (if_block0)
        if_block0.m(div3, null);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, span);
      if (if_block1)
        if_block1.m(span, null);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div0);
      if (prepend_slot) {
        prepend_slot.m(div0, null);
      }
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div1);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, input0);
      if (input0.autofocus)
        input0.focus();
      ctx[93](input0);
      set_input_value(
        input0,
        /*filterText*/
        ctx[4]
      );
      append_hydration_dev(div3, t4);
      append_hydration_dev(div3, div2);
      if (if_block3)
        if_block3.m(div2, null);
      append_hydration_dev(div2, t5);
      if (if_block4)
        if_block4.m(div2, null);
      append_hydration_dev(div2, t6);
      if (if_block5)
        if_block5.m(div2, null);
      append_hydration_dev(div3, t7);
      append_hydration_dev(div3, input1);
      append_hydration_dev(div3, t8);
      if (if_block6)
        if_block6.m(div3, null);
      ctx[95](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "click",
            /*handleClickOutside*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "keydown",
            /*handleKeyDown*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "keydown",
            /*handleKeyDown*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "blur",
            /*handleBlur*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "focus",
            /*handleFocus*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[94]
          ),
          listen_dev(div3, "pointerup", prevent_default(
            /*handleClick*/
            ctx[40]
          ), false, true, false, false),
          listen_dev(div3, "mousedown", prevent_default(
            /*mousedown_handler*/
            ctx[83]
          ), false, true, false, false),
          action_destroyer(floatingRef_action = /*floatingRef*/
          ctx[48].call(null, div3))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*listOpen*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*listOpen*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*focused*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (prepend_slot) {
        if (prepend_slot.p && (!current || dirty[2] & /*$$scope*/
        524288)) {
          update_slot_base(
            prepend_slot,
            prepend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[81],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[81]
            ) : get_slot_changes(
              prepend_slot_template,
              /*$$scope*/
              ctx2[81],
              dirty,
              get_prepend_slot_changes
            ),
            get_prepend_slot_context
          );
        }
      }
      if (
        /*hasValue*/
        ctx2[25]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasValue*/
          33554432) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(input0, input_data_1 = get_spread_update(input0_levels, [
        (!current || dirty[0] & /*searchable*/
        131072 && input0_readonly_value !== (input0_readonly_value = !/*searchable*/
        ctx2[17])) && { readOnly: input0_readonly_value },
        dirty[0] & /*_inputAttributes*/
        134217728 && /*_inputAttributes*/
        ctx2[27],
        (!current || dirty[1] & /*placeholderText*/
        4) && { placeholder: (
          /*placeholderText*/
          ctx2[33]
        ) },
        (!current || dirty[0] & /*inputStyles*/
        262144) && { style: (
          /*inputStyles*/
          ctx2[18]
        ) },
        (!current || dirty[0] & /*disabled*/
        2048) && { disabled: (
          /*disabled*/
          ctx2[11]
        ) }
      ]));
      if (dirty[0] & /*filterText*/
      16 && input0.value !== /*filterText*/
      ctx2[4]) {
        set_input_value(
          input0,
          /*filterText*/
          ctx2[4]
        );
      }
      toggle_class(input0, "svelte-apvs86", true);
      if (
        /*loading*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*loading*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*showClear*/
        ctx2[34]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*showClear*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*showChevron*/
        ctx2[20]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*showChevron*/
          1048576) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*name*/
      256) {
        attr_dev(
          input1,
          "name",
          /*name*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*value*/
      8 && input1_value_value !== (input1_value_value = /*value*/
      ctx2[3] ? JSON.stringify(
        /*value*/
        ctx2[3]
      ) : null)) {
        prop_dev(input1, "value", input1_value_value);
      }
      if (
        /*required*/
        ctx2[16] && (!/*value*/
        ctx2[3] || /*value*/
        ctx2[3].length === 0)
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & /*required, value*/
          65544) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div3, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*containerClasses*/
      2097152 && div3_class_value !== (div3_class_value = "svelte-select " + /*containerClasses*/
      ctx2[21] + " svelte-apvs86")) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*containerStyles*/
      16384) {
        attr_dev(
          div3,
          "style",
          /*containerStyles*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*containerClasses, multiple*/
      2097664) {
        toggle_class(
          div3,
          "multi",
          /*multiple*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*containerClasses, disabled*/
      2099200) {
        toggle_class(
          div3,
          "disabled",
          /*disabled*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*containerClasses, focused*/
      2097156) {
        toggle_class(
          div3,
          "focused",
          /*focused*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*containerClasses, listOpen*/
      2097216) {
        toggle_class(
          div3,
          "list-open",
          /*listOpen*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*containerClasses, showChevron*/
      3145728) {
        toggle_class(
          div3,
          "show-chevron",
          /*showChevron*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*containerClasses, hasError*/
      2129920) {
        toggle_class(
          div3,
          "error",
          /*hasError*/
          ctx2[15]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(prepend_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(prepend_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (prepend_slot)
        prepend_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      ctx[93](null);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      ctx[95](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function convertStringItemsToObjects(_items) {
  return _items.map((item, index) => {
    return { index, value: item, label: `${item}` };
  });
}
function isItemFirst(itemIndex) {
  return itemIndex === 0;
}
function isItemSelectable(item) {
  return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty("selectable");
}
function instance4($$self, $$props, $$invalidate) {
  let hasValue;
  let hideSelectedItem;
  let showClear;
  let placeholderText;
  let ariaSelection;
  let ariaContext;
  let filteredItems;
  let listDom;
  let scrollToHoverItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, [
    "list-prepend",
    "list",
    "item",
    "empty",
    "list-append",
    "prepend",
    "selection",
    "multi-clear-icon",
    "loading-icon",
    "clear-icon",
    "chevron-icon",
    "required"
  ]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { justValue = null } = $$props;
  let { filter: filter2 = filter } = $$props;
  let { getItems: getItems2 = getItems } = $$props;
  let { id = null } = $$props;
  let { name = null } = $$props;
  let { container = void 0 } = $$props;
  let { input = void 0 } = $$props;
  let { multiple = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { disabled = false } = $$props;
  let { focused = false } = $$props;
  let { value = null } = $$props;
  let { filterText = "" } = $$props;
  let { placeholder = "Please select" } = $$props;
  let { placeholderAlwaysShow = false } = $$props;
  let { items = null } = $$props;
  let { label = "label" } = $$props;
  let { itemFilter = (label2, filterText2, option) => `${label2}`.toLowerCase().includes(filterText2.toLowerCase()) } = $$props;
  let { groupBy = void 0 } = $$props;
  let { groupFilter = (groups) => groups } = $$props;
  let { groupHeaderSelectable = false } = $$props;
  let { itemId = "value" } = $$props;
  let { loadOptions = void 0 } = $$props;
  let { containerStyles = "" } = $$props;
  let { hasError = false } = $$props;
  let { filterSelectedItems = true } = $$props;
  let { required = false } = $$props;
  let { closeListOnChange = true } = $$props;
  let { createGroupHeaderItem = (groupValue, item) => {
    return { value: groupValue, [label]: groupValue };
  } } = $$props;
  const getFilteredItems = () => {
    return filteredItems;
  };
  let { searchable = true } = $$props;
  let { inputStyles = "" } = $$props;
  let { clearable = true } = $$props;
  let { loading = false } = $$props;
  let { listOpen = false } = $$props;
  let timeout;
  let { debounce = (fn, wait = 1) => {
    clearTimeout(timeout);
    timeout = setTimeout(fn, wait);
  } } = $$props;
  let { debounceWait = 300 } = $$props;
  let { hideEmptyState = false } = $$props;
  let { inputAttributes = {} } = $$props;
  let { listAutoWidth = true } = $$props;
  let { showChevron = false } = $$props;
  let { listOffset = 5 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { floatingConfig = {} } = $$props;
  let { class: containerClasses = "" } = $$props;
  let activeValue;
  let prev_value;
  let prev_filterText;
  let prev_multiple;
  function setValue() {
    if (typeof value === "string") {
      let item = (items || []).find((item2) => item2[itemId] === value);
      $$invalidate(3, value = item || { [itemId]: value, label: value });
    } else if (multiple && Array.isArray(value) && value.length > 0) {
      $$invalidate(3, value = value.map((item) => typeof item === "string" ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes;
  function assignInputAttributes() {
    $$invalidate(27, _inputAttributes = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes
    ));
    if (id) {
      $$invalidate(27, _inputAttributes["id"] = id, _inputAttributes);
    }
    if (!searchable) {
      $$invalidate(27, _inputAttributes["readonly"] = true, _inputAttributes);
    }
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
            id: groupValue,
            groupHeader: true,
            selectable: groupHeaderSelectable
          }));
        }
      }
      groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter(groupValues).forEach((groupValue) => {
      if (groups[groupValue])
        sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (multiple) {
      if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
        if (checkValueForDuplicates()) {
          dispatch("input", value);
        }
      }
      return;
    }
    if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {
      dispatch("input", value);
    }
  }
  function setupMulti() {
    if (value) {
      if (Array.isArray(value)) {
        $$invalidate(3, value = [...value]);
      } else {
        $$invalidate(3, value = [value]);
      }
    }
  }
  function setupSingle() {
    if (value)
      $$invalidate(3, value = null);
  }
  function setValueIndexAsHoverIndex() {
    const valueIndex = filteredItems.findIndex((i) => {
      return i[itemId] === value[itemId];
    });
    checkHoverSelectable(valueIndex, true);
  }
  function dispatchHover(i) {
    dispatch("hoverItem", i);
  }
  function checkHoverSelectable(startingIndex = 0, ignoreGroup) {
    $$invalidate(7, hoverItemIndex = startingIndex < 0 ? 0 : startingIndex);
    if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {
      setHoverIndex(1);
    }
  }
  function setupFilterText() {
    if (!loadOptions && filterText.length === 0)
      return;
    if (loadOptions) {
      debounce(
        async function() {
          $$invalidate(5, loading = true);
          let res = await getItems2({
            dispatch,
            loadOptions,
            convertStringItemsToObjects,
            filterText
          });
          if (res) {
            $$invalidate(5, loading = res.loading);
            $$invalidate(6, listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false);
            $$invalidate(2, focused = listOpen && res.focused);
            $$invalidate(51, items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems);
          } else {
            $$invalidate(5, loading = false);
            $$invalidate(2, focused = true);
            $$invalidate(6, listOpen = true);
          }
        },
        debounceWait
      );
    } else {
      $$invalidate(6, listOpen = true);
      if (multiple) {
        $$invalidate(26, activeValue = void 0);
      }
    }
  }
  function handleFilterEvent(items2) {
    if (listOpen)
      dispatch("filter", items2);
  }
  beforeUpdate(async () => {
    $$invalidate(77, prev_value = value);
    $$invalidate(78, prev_filterText = filterText);
    $$invalidate(79, prev_multiple = multiple);
  });
  function computeJustValue() {
    if (multiple)
      return value ? value.map((item) => item[itemId]) : null;
    return value ? value[itemId] : value;
  }
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value) {
      const ids = [];
      const uniqueValues = [];
      value.forEach((val) => {
        if (!ids.includes(val[itemId])) {
          ids.push(val[itemId]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates)
        $$invalidate(3, value = uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[itemId] : value[itemId];
    return items.find((item) => item[itemId] === matchTo);
  }
  function updateValueDisplay(items2) {
    if (!items2 || items2.length === 0 || items2.some((item) => typeof item !== "object"))
      return;
    if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId]))
      return;
    if (Array.isArray(value)) {
      $$invalidate(3, value = value.map((selection) => findItem(selection) || selection));
    } else {
      $$invalidate(3, value = findItem() || value);
    }
  }
  async function handleMultiItemClear(i) {
    const itemToRemove = value[i];
    if (value.length === 1) {
      $$invalidate(3, value = void 0);
    } else {
      $$invalidate(3, value = value.filter((item) => {
        return item !== itemToRemove;
      }));
    }
    dispatch("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!focused)
      return;
    e.stopPropagation();
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "Enter":
        e.preventDefault();
        if (listOpen) {
          if (filteredItems.length === 0)
            break;
          const hoverItem = filteredItems[hoverItemIndex];
          if (value && !multiple && value[itemId] === hoverItem[itemId]) {
            closeList();
            break;
          } else {
            handleSelect(filteredItems[hoverItemIndex]);
          }
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = void 0);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(-1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = void 0);
        }
        break;
      case "Tab":
        if (listOpen && focused) {
          if (filteredItems.length === 0 || value && value[itemId] === filteredItems[hoverItemIndex][itemId])
            return closeList();
          e.preventDefault();
          handleSelect(filteredItems[hoverItemIndex]);
          closeList();
        }
        break;
      case "Backspace":
        if (!multiple || filterText.length > 0)
          return;
        if (multiple && value && value.length > 0) {
          handleMultiItemClear(activeValue !== void 0 ? activeValue : value.length - 1);
          if (activeValue === 0 || activeValue === void 0)
            break;
          $$invalidate(26, activeValue = value.length > activeValue ? activeValue - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!value || !multiple || filterText.length > 0)
          return;
        if (activeValue === void 0) {
          $$invalidate(26, activeValue = value.length - 1);
        } else if (value.length > activeValue && activeValue !== 0) {
          $$invalidate(26, activeValue -= 1);
        }
        break;
      case "ArrowRight":
        if (!value || !multiple || filterText.length > 0 || activeValue === void 0)
          return;
        if (activeValue === value.length - 1) {
          $$invalidate(26, activeValue = void 0);
        } else if (activeValue < value.length - 1) {
          $$invalidate(26, activeValue += 1);
        }
        break;
    }
  }
  function handleFocus(e) {
    if (focused && input === (document == null ? void 0 : document.activeElement))
      return;
    if (e)
      dispatch("focus", e);
    input.focus();
    $$invalidate(2, focused = true);
  }
  async function handleBlur(e) {
    if (isScrolling)
      return;
    if (listOpen || focused) {
      dispatch("blur", e);
      closeList();
      $$invalidate(2, focused = false);
      $$invalidate(26, activeValue = void 0);
      input.blur();
    }
  }
  function handleClick() {
    if (disabled)
      return;
    $$invalidate(6, listOpen = !listOpen);
  }
  function handleClear() {
    dispatch("clear", value);
    $$invalidate(3, value = void 0);
    closeList();
    handleFocus();
  }
  onMount(() => {
    if (listOpen)
      $$invalidate(2, focused = true);
    if (focused && input)
      input.focus();
  });
  function itemSelected(selection) {
    if (selection) {
      $$invalidate(4, filterText = "");
      const item = Object.assign({}, selection);
      if (item.groupHeader && !item.selectable)
        return;
      $$invalidate(3, value = multiple ? value ? value.concat([item]) : [item] : $$invalidate(3, value = item));
      setTimeout(() => {
        if (closeListOnChange)
          closeList();
        $$invalidate(26, activeValue = void 0);
        dispatch("change", value);
        dispatch("select", selection);
      });
    }
  }
  function closeList() {
    $$invalidate(4, filterText = "");
    $$invalidate(6, listOpen = false);
  }
  let { ariaValues = (values) => {
    return `Option ${values}, selected.`;
  } } = $$props;
  let { ariaListOpen = (label2, count) => {
    return `You are currently focused on option ${label2}. There are ${count} results available.`;
  } } = $$props;
  let { ariaFocused = () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  } } = $$props;
  function handleAriaSelection(_multiple) {
    let selected = void 0;
    if (_multiple && value.length > 0) {
      selected = value.map((v) => v[label]).join(", ");
    } else {
      selected = value[label];
    }
    return ariaValues(selected);
  }
  function handleAriaContent() {
    if (!filteredItems || filteredItems.length === 0)
      return "";
    let _item = filteredItems[hoverItemIndex];
    if (listOpen && _item) {
      let count = filteredItems ? filteredItems.length : 0;
      return ariaListOpen(_item[label], count);
    } else {
      return ariaFocused();
    }
  }
  let list = null;
  let isScrollingTimer;
  function handleListScroll() {
    clearTimeout(isScrollingTimer);
    isScrollingTimer = setTimeout(
      () => {
        isScrolling = false;
      },
      100
    );
  }
  function handleClickOutside(event) {
    if (!listOpen && !focused && container && !container.contains(event.target) && !(list == null ? void 0 : list.contains(event.target))) {
      handleBlur();
    }
  }
  onDestroy(() => {
    list == null ? void 0 : list.remove();
  });
  let isScrolling = false;
  function handleSelect(item) {
    if (!item || item.selectable === false)
      return;
    itemSelected(item);
  }
  function handleHover(i) {
    if (isScrolling)
      return;
    $$invalidate(7, hoverItemIndex = i);
  }
  function handleItemClick(args) {
    const { item, i } = args;
    if ((item == null ? void 0 : item.selectable) === false)
      return;
    if (value && !multiple && value[itemId] === item[itemId])
      return closeList();
    if (isItemSelectable(item)) {
      $$invalidate(7, hoverItemIndex = i);
      handleSelect(item);
    }
  }
  function setHoverIndex(increment) {
    let selectableFilteredItems = filteredItems.filter((item) => !Object.hasOwn(item, "selectable") || item.selectable === true);
    if (selectableFilteredItems.length === 0) {
      return $$invalidate(7, hoverItemIndex = 0);
    }
    if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {
      $$invalidate(7, hoverItemIndex = 0);
    } else if (increment < 0 && hoverItemIndex === 0) {
      $$invalidate(7, hoverItemIndex = filteredItems.length - 1);
    } else {
      $$invalidate(7, hoverItemIndex = hoverItemIndex + increment);
    }
    const hover = filteredItems[hoverItemIndex];
    if (hover && hover.selectable === false) {
      if (increment === 1 || increment === -1)
        setHoverIndex(increment);
      return;
    }
  }
  function isItemActive(item, value2, itemId2) {
    if (multiple)
      return;
    return value2 && value2[itemId2] === item[itemId2];
  }
  const activeScroll = scrollAction;
  const hoverScroll = scrollAction;
  function scrollAction(node) {
    return {
      update(args) {
        if (args.scroll) {
          handleListScroll();
          node.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    };
  }
  function setListWidth() {
    const { width } = container.getBoundingClientRect();
    $$invalidate(23, list.style.width = listAutoWidth ? width + "px" : "auto", list);
  }
  let _floatingConfig = {
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [offset(listOffset), flip(), shift()],
    autoUpdate: false
  };
  const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(_floatingConfig);
  let prefloat = true;
  function listMounted(list2, listOpen2) {
    if (!list2 || !listOpen2)
      return $$invalidate(28, prefloat = true);
    setTimeout(
      () => {
        $$invalidate(28, prefloat = false);
      },
      0
    );
  }
  const writable_props = [
    "justValue",
    "filter",
    "getItems",
    "id",
    "name",
    "container",
    "input",
    "multiple",
    "multiFullItemClearable",
    "disabled",
    "focused",
    "value",
    "filterText",
    "placeholder",
    "placeholderAlwaysShow",
    "items",
    "label",
    "itemFilter",
    "groupBy",
    "groupFilter",
    "groupHeaderSelectable",
    "itemId",
    "loadOptions",
    "containerStyles",
    "hasError",
    "filterSelectedItems",
    "required",
    "closeListOnChange",
    "createGroupHeaderItem",
    "searchable",
    "inputStyles",
    "clearable",
    "loading",
    "listOpen",
    "debounce",
    "debounceWait",
    "hideEmptyState",
    "inputAttributes",
    "listAutoWidth",
    "showChevron",
    "listOffset",
    "hoverItemIndex",
    "floatingConfig",
    "class",
    "ariaValues",
    "ariaListOpen",
    "ariaFocused"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  const mouseover_handler = (i) => handleHover(i);
  const focus_handler = (i) => handleHover(i);
  const click_handler = (item, i) => handleItemClick({ item, i });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(23, list);
    });
  }
  const pointerup_handler_1 = (i) => handleMultiItemClear(i);
  const click_handler_1 = (i) => multiFullItemClearable ? handleMultiItemClear(i) : {};
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input);
    });
  }
  function input0_input_handler() {
    filterText = this.value;
    $$invalidate(4, filterText);
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("justValue" in $$props2)
      $$invalidate(52, justValue = $$props2.justValue);
    if ("filter" in $$props2)
      $$invalidate(53, filter2 = $$props2.filter);
    if ("getItems" in $$props2)
      $$invalidate(54, getItems2 = $$props2.getItems);
    if ("id" in $$props2)
      $$invalidate(55, id = $$props2.id);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(1, input = $$props2.input);
    if ("multiple" in $$props2)
      $$invalidate(9, multiple = $$props2.multiple);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(10, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("disabled" in $$props2)
      $$invalidate(11, disabled = $$props2.disabled);
    if ("focused" in $$props2)
      $$invalidate(2, focused = $$props2.focused);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(4, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(56, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(57, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(51, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("itemFilter" in $$props2)
      $$invalidate(58, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(59, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(60, groupFilter = $$props2.groupFilter);
    if ("groupHeaderSelectable" in $$props2)
      $$invalidate(61, groupHeaderSelectable = $$props2.groupHeaderSelectable);
    if ("itemId" in $$props2)
      $$invalidate(13, itemId = $$props2.itemId);
    if ("loadOptions" in $$props2)
      $$invalidate(62, loadOptions = $$props2.loadOptions);
    if ("containerStyles" in $$props2)
      $$invalidate(14, containerStyles = $$props2.containerStyles);
    if ("hasError" in $$props2)
      $$invalidate(15, hasError = $$props2.hasError);
    if ("filterSelectedItems" in $$props2)
      $$invalidate(63, filterSelectedItems = $$props2.filterSelectedItems);
    if ("required" in $$props2)
      $$invalidate(16, required = $$props2.required);
    if ("closeListOnChange" in $$props2)
      $$invalidate(64, closeListOnChange = $$props2.closeListOnChange);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(65, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("searchable" in $$props2)
      $$invalidate(17, searchable = $$props2.searchable);
    if ("inputStyles" in $$props2)
      $$invalidate(18, inputStyles = $$props2.inputStyles);
    if ("clearable" in $$props2)
      $$invalidate(67, clearable = $$props2.clearable);
    if ("loading" in $$props2)
      $$invalidate(5, loading = $$props2.loading);
    if ("listOpen" in $$props2)
      $$invalidate(6, listOpen = $$props2.listOpen);
    if ("debounce" in $$props2)
      $$invalidate(68, debounce = $$props2.debounce);
    if ("debounceWait" in $$props2)
      $$invalidate(69, debounceWait = $$props2.debounceWait);
    if ("hideEmptyState" in $$props2)
      $$invalidate(19, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(70, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(71, listAutoWidth = $$props2.listAutoWidth);
    if ("showChevron" in $$props2)
      $$invalidate(20, showChevron = $$props2.showChevron);
    if ("listOffset" in $$props2)
      $$invalidate(72, listOffset = $$props2.listOffset);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(7, hoverItemIndex = $$props2.hoverItemIndex);
    if ("floatingConfig" in $$props2)
      $$invalidate(73, floatingConfig = $$props2.floatingConfig);
    if ("class" in $$props2)
      $$invalidate(21, containerClasses = $$props2.class);
    if ("ariaValues" in $$props2)
      $$invalidate(74, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(75, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(76, ariaFocused = $$props2.ariaFocused);
    if ("$$scope" in $$props2)
      $$invalidate(81, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    beforeUpdate,
    createEventDispatcher,
    onDestroy,
    onMount,
    offset,
    flip,
    shift,
    createFloatingActions,
    dispatch,
    _filter: filter,
    _getItems: getItems,
    ChevronIcon: ChevronIcon_default,
    ClearIcon: ClearIcon_default,
    LoadingIcon: LoadingIcon_default,
    justValue,
    filter: filter2,
    getItems: getItems2,
    id,
    name,
    container,
    input,
    multiple,
    multiFullItemClearable,
    disabled,
    focused,
    value,
    filterText,
    placeholder,
    placeholderAlwaysShow,
    items,
    label,
    itemFilter,
    groupBy,
    groupFilter,
    groupHeaderSelectable,
    itemId,
    loadOptions,
    containerStyles,
    hasError,
    filterSelectedItems,
    required,
    closeListOnChange,
    createGroupHeaderItem,
    getFilteredItems,
    searchable,
    inputStyles,
    clearable,
    loading,
    listOpen,
    timeout,
    debounce,
    debounceWait,
    hideEmptyState,
    inputAttributes,
    listAutoWidth,
    showChevron,
    listOffset,
    hoverItemIndex,
    floatingConfig,
    containerClasses,
    activeValue,
    prev_value,
    prev_filterText,
    prev_multiple,
    setValue,
    _inputAttributes,
    assignInputAttributes,
    convertStringItemsToObjects,
    filterGroupedItems,
    dispatchSelectedItem,
    setupMulti,
    setupSingle,
    setValueIndexAsHoverIndex,
    dispatchHover,
    checkHoverSelectable,
    setupFilterText,
    handleFilterEvent,
    computeJustValue,
    checkValueForDuplicates,
    findItem,
    updateValueDisplay,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleBlur,
    handleClick,
    handleClear,
    itemSelected,
    closeList,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    handleAriaSelection,
    handleAriaContent,
    list,
    isScrollingTimer,
    handleListScroll,
    handleClickOutside,
    isScrolling,
    handleSelect,
    handleHover,
    handleItemClick,
    setHoverIndex,
    isItemActive,
    isItemFirst,
    isItemSelectable,
    activeScroll,
    hoverScroll,
    scrollAction,
    setListWidth,
    _floatingConfig,
    floatingRef,
    floatingContent,
    floatingUpdate,
    prefloat,
    listMounted,
    filteredItems,
    scrollToHoverItem,
    listDom,
    ariaContext,
    ariaSelection,
    placeholderText,
    hasValue,
    showClear,
    hideSelectedItem
  });
  $$self.$inject_state = ($$props2) => {
    if ("justValue" in $$props2)
      $$invalidate(52, justValue = $$props2.justValue);
    if ("filter" in $$props2)
      $$invalidate(53, filter2 = $$props2.filter);
    if ("getItems" in $$props2)
      $$invalidate(54, getItems2 = $$props2.getItems);
    if ("id" in $$props2)
      $$invalidate(55, id = $$props2.id);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(1, input = $$props2.input);
    if ("multiple" in $$props2)
      $$invalidate(9, multiple = $$props2.multiple);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(10, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("disabled" in $$props2)
      $$invalidate(11, disabled = $$props2.disabled);
    if ("focused" in $$props2)
      $$invalidate(2, focused = $$props2.focused);
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(4, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(56, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(57, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(51, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(12, label = $$props2.label);
    if ("itemFilter" in $$props2)
      $$invalidate(58, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(59, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(60, groupFilter = $$props2.groupFilter);
    if ("groupHeaderSelectable" in $$props2)
      $$invalidate(61, groupHeaderSelectable = $$props2.groupHeaderSelectable);
    if ("itemId" in $$props2)
      $$invalidate(13, itemId = $$props2.itemId);
    if ("loadOptions" in $$props2)
      $$invalidate(62, loadOptions = $$props2.loadOptions);
    if ("containerStyles" in $$props2)
      $$invalidate(14, containerStyles = $$props2.containerStyles);
    if ("hasError" in $$props2)
      $$invalidate(15, hasError = $$props2.hasError);
    if ("filterSelectedItems" in $$props2)
      $$invalidate(63, filterSelectedItems = $$props2.filterSelectedItems);
    if ("required" in $$props2)
      $$invalidate(16, required = $$props2.required);
    if ("closeListOnChange" in $$props2)
      $$invalidate(64, closeListOnChange = $$props2.closeListOnChange);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(65, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("searchable" in $$props2)
      $$invalidate(17, searchable = $$props2.searchable);
    if ("inputStyles" in $$props2)
      $$invalidate(18, inputStyles = $$props2.inputStyles);
    if ("clearable" in $$props2)
      $$invalidate(67, clearable = $$props2.clearable);
    if ("loading" in $$props2)
      $$invalidate(5, loading = $$props2.loading);
    if ("listOpen" in $$props2)
      $$invalidate(6, listOpen = $$props2.listOpen);
    if ("timeout" in $$props2)
      timeout = $$props2.timeout;
    if ("debounce" in $$props2)
      $$invalidate(68, debounce = $$props2.debounce);
    if ("debounceWait" in $$props2)
      $$invalidate(69, debounceWait = $$props2.debounceWait);
    if ("hideEmptyState" in $$props2)
      $$invalidate(19, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(70, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(71, listAutoWidth = $$props2.listAutoWidth);
    if ("showChevron" in $$props2)
      $$invalidate(20, showChevron = $$props2.showChevron);
    if ("listOffset" in $$props2)
      $$invalidate(72, listOffset = $$props2.listOffset);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(7, hoverItemIndex = $$props2.hoverItemIndex);
    if ("floatingConfig" in $$props2)
      $$invalidate(73, floatingConfig = $$props2.floatingConfig);
    if ("containerClasses" in $$props2)
      $$invalidate(21, containerClasses = $$props2.containerClasses);
    if ("activeValue" in $$props2)
      $$invalidate(26, activeValue = $$props2.activeValue);
    if ("prev_value" in $$props2)
      $$invalidate(77, prev_value = $$props2.prev_value);
    if ("prev_filterText" in $$props2)
      $$invalidate(78, prev_filterText = $$props2.prev_filterText);
    if ("prev_multiple" in $$props2)
      $$invalidate(79, prev_multiple = $$props2.prev_multiple);
    if ("_inputAttributes" in $$props2)
      $$invalidate(27, _inputAttributes = $$props2._inputAttributes);
    if ("ariaValues" in $$props2)
      $$invalidate(74, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(75, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(76, ariaFocused = $$props2.ariaFocused);
    if ("list" in $$props2)
      $$invalidate(23, list = $$props2.list);
    if ("isScrollingTimer" in $$props2)
      isScrollingTimer = $$props2.isScrollingTimer;
    if ("isScrolling" in $$props2)
      isScrolling = $$props2.isScrolling;
    if ("_floatingConfig" in $$props2)
      $$invalidate(80, _floatingConfig = $$props2._floatingConfig);
    if ("prefloat" in $$props2)
      $$invalidate(28, prefloat = $$props2.prefloat);
    if ("filteredItems" in $$props2)
      $$invalidate(24, filteredItems = $$props2.filteredItems);
    if ("scrollToHoverItem" in $$props2)
      $$invalidate(29, scrollToHoverItem = $$props2.scrollToHoverItem);
    if ("listDom" in $$props2)
      $$invalidate(30, listDom = $$props2.listDom);
    if ("ariaContext" in $$props2)
      $$invalidate(31, ariaContext = $$props2.ariaContext);
    if ("ariaSelection" in $$props2)
      $$invalidate(32, ariaSelection = $$props2.ariaSelection);
    if ("placeholderText" in $$props2)
      $$invalidate(33, placeholderText = $$props2.placeholderText);
    if ("hasValue" in $$props2)
      $$invalidate(25, hasValue = $$props2.hasValue);
    if ("showClear" in $$props2)
      $$invalidate(34, showClear = $$props2.showClear);
    if ("hideSelectedItem" in $$props2)
      $$invalidate(35, hideSelectedItem = $$props2.hideSelectedItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    8 | $$self.$$.dirty[1] & /*items*/
    1048576) {
      $:
        if (items, value)
          setValue();
    }
    if ($$self.$$.dirty[0] & /*searchable*/
    131072 | $$self.$$.dirty[2] & /*inputAttributes*/
    256) {
      $:
        if (inputAttributes || !searchable)
          assignInputAttributes();
    }
    if ($$self.$$.dirty[0] & /*multiple*/
    512) {
      $:
        if (multiple)
          setupMulti();
    }
    if ($$self.$$.dirty[0] & /*multiple*/
    512 | $$self.$$.dirty[2] & /*prev_multiple*/
    131072) {
      $:
        if (prev_multiple && !multiple)
          setupSingle();
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520) {
      $:
        if (multiple && value && value.length > 1)
          checkValueForDuplicates();
    }
    if ($$self.$$.dirty[0] & /*value*/
    8) {
      $:
        if (value)
          dispatchSelectedItem();
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/
    520 | $$self.$$.dirty[2] & /*prev_value*/
    32768) {
      $:
        if (!value && multiple && prev_value)
          dispatch("input", value);
    }
    if ($$self.$$.dirty[0] & /*focused, input*/
    6) {
      $:
        if (!focused && input)
          closeList();
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    16 | $$self.$$.dirty[2] & /*prev_filterText*/
    65536) {
      $:
        if (filterText !== prev_filterText)
          setupFilterText();
    }
    if ($$self.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/
    12824 | $$self.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/
    407896064 | $$self.$$.dirty[2] & /*loadOptions, filterSelectedItems*/
    3) {
      $:
        $$invalidate(24, filteredItems = filter2({
          loadOptions,
          filterText,
          items,
          multiple,
          value,
          itemId,
          groupBy,
          label,
          filterSelectedItems,
          itemFilter,
          convertStringItemsToObjects,
          filterGroupedItems
        }));
    }
    if ($$self.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/
    16777800) {
      $:
        if (!multiple && listOpen && value && filteredItems)
          setValueIndexAsHoverIndex();
    }
    if ($$self.$$.dirty[0] & /*listOpen, multiple*/
    576) {
      $:
        if (listOpen && multiple)
          $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    16) {
      $:
        if (filterText)
          $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/
    128) {
      $:
        dispatchHover(hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520) {
      $:
        $$invalidate(25, hasValue = multiple ? value && value.length > 0 : value);
    }
    if ($$self.$$.dirty[0] & /*hasValue, filterText*/
    33554448) {
      $:
        $$invalidate(35, hideSelectedItem = hasValue && filterText.length > 0);
    }
    if ($$self.$$.dirty[0] & /*hasValue, disabled, loading*/
    33556512 | $$self.$$.dirty[2] & /*clearable*/
    32) {
      $:
        $$invalidate(34, showClear = hasValue && clearable && !disabled && !loading);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/
    100663296) {
      $:
        $$invalidate(33, placeholderText = placeholderAlwaysShow && multiple ? placeholder : multiple && (value == null ? void 0 : value.length) === 0 ? placeholder : value ? "" : placeholder);
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/
    520) {
      $:
        $$invalidate(32, ariaSelection = value ? handleAriaSelection(multiple) : "");
    }
    if ($$self.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/
    16777412) {
      $:
        $$invalidate(31, ariaContext = handleAriaContent({
          filteredItems,
          hoverItemIndex,
          focused,
          listOpen
        }));
    }
    if ($$self.$$.dirty[1] & /*items*/
    1048576) {
      $:
        updateValueDisplay(items);
    }
    if ($$self.$$.dirty[0] & /*multiple, value, itemId*/
    8712) {
      $:
        $$invalidate(52, justValue = computeJustValue(multiple, value, itemId));
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520 | $$self.$$.dirty[2] & /*prev_value*/
    32768) {
      $:
        if (!multiple && prev_value && !value)
          dispatch("input", value);
    }
    if ($$self.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/
    16777800) {
      $:
        if (listOpen && filteredItems && !multiple && !value)
          checkHoverSelectable();
    }
    if ($$self.$$.dirty[0] & /*filteredItems*/
    16777216) {
      $:
        handleFilterEvent(filteredItems);
    }
    if ($$self.$$.dirty[0] & /*container*/
    1 | $$self.$$.dirty[2] & /*floatingConfig*/
    2048) {
      $:
        if (container && (floatingConfig == null ? void 0 : floatingConfig.autoUpdate) === void 0) {
          $$invalidate(80, _floatingConfig.autoUpdate = true, _floatingConfig);
        }
    }
    if ($$self.$$.dirty[0] & /*container*/
    1 | $$self.$$.dirty[2] & /*floatingConfig, _floatingConfig*/
    264192) {
      $:
        if (container && floatingConfig)
          floatingUpdate(Object.assign(_floatingConfig, floatingConfig));
    }
    if ($$self.$$.dirty[0] & /*list*/
    8388608) {
      $:
        $$invalidate(30, listDom = !!list);
    }
    if ($$self.$$.dirty[0] & /*list, listOpen*/
    8388672) {
      $:
        listMounted(list, listOpen);
    }
    if ($$self.$$.dirty[0] & /*listOpen, container, list*/
    8388673) {
      $:
        if (listOpen && container && list)
          setListWidth();
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/
    128) {
      $:
        $$invalidate(29, scrollToHoverItem = hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*input, listOpen, focused*/
    70) {
      $:
        if (input && listOpen && !focused)
          handleFocus();
    }
  };
  return [
    container,
    input,
    focused,
    value,
    filterText,
    loading,
    listOpen,
    hoverItemIndex,
    name,
    multiple,
    multiFullItemClearable,
    disabled,
    label,
    itemId,
    containerStyles,
    hasError,
    required,
    searchable,
    inputStyles,
    hideEmptyState,
    showChevron,
    containerClasses,
    handleClear,
    list,
    filteredItems,
    hasValue,
    activeValue,
    _inputAttributes,
    prefloat,
    scrollToHoverItem,
    listDom,
    ariaContext,
    ariaSelection,
    placeholderText,
    showClear,
    hideSelectedItem,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleBlur,
    handleClick,
    handleListScroll,
    handleClickOutside,
    handleHover,
    handleItemClick,
    isItemActive,
    activeScroll,
    hoverScroll,
    floatingRef,
    floatingContent,
    $$slots,
    items,
    justValue,
    filter2,
    getItems2,
    id,
    placeholder,
    placeholderAlwaysShow,
    itemFilter,
    groupBy,
    groupFilter,
    groupHeaderSelectable,
    loadOptions,
    filterSelectedItems,
    closeListOnChange,
    createGroupHeaderItem,
    getFilteredItems,
    clearable,
    debounce,
    debounceWait,
    inputAttributes,
    listAutoWidth,
    listOffset,
    floatingConfig,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    prev_value,
    prev_filterText,
    prev_multiple,
    _floatingConfig,
    $$scope,
    slots,
    mousedown_handler,
    keydown_handler_1,
    pointerup_handler,
    keydown_handler,
    mouseover_handler,
    focus_handler,
    click_handler,
    div_binding,
    pointerup_handler_1,
    click_handler_1,
    input0_binding,
    input0_input_handler,
    div3_binding
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        justValue: 52,
        filter: 53,
        getItems: 54,
        id: 55,
        name: 8,
        container: 0,
        input: 1,
        multiple: 9,
        multiFullItemClearable: 10,
        disabled: 11,
        focused: 2,
        value: 3,
        filterText: 4,
        placeholder: 56,
        placeholderAlwaysShow: 57,
        items: 51,
        label: 12,
        itemFilter: 58,
        groupBy: 59,
        groupFilter: 60,
        groupHeaderSelectable: 61,
        itemId: 13,
        loadOptions: 62,
        containerStyles: 14,
        hasError: 15,
        filterSelectedItems: 63,
        required: 16,
        closeListOnChange: 64,
        createGroupHeaderItem: 65,
        getFilteredItems: 66,
        searchable: 17,
        inputStyles: 18,
        clearable: 67,
        loading: 5,
        listOpen: 6,
        debounce: 68,
        debounceWait: 69,
        hideEmptyState: 19,
        inputAttributes: 70,
        listAutoWidth: 71,
        showChevron: 20,
        listOffset: 72,
        hoverItemIndex: 7,
        floatingConfig: 73,
        class: 21,
        handleClear: 22,
        ariaValues: 74,
        ariaListOpen: 75,
        ariaFocused: 76
      },
      add_css4,
      [-1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment4.name
    });
  }
  get justValue() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justValue(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getItems() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiFullItemClearable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiFullItemClearable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focused() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focused(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterText() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterText(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholderAlwaysShow() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholderAlwaysShow(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemFilter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemFilter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupBy() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupBy(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupFilter() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupFilter(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupHeaderSelectable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupHeaderSelectable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemId() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemId(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loadOptions() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loadOptions(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get containerStyles() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set containerStyles(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasError() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasError(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterSelectedItems() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterSelectedItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeListOnChange() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeListOnChange(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createGroupHeaderItem() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createGroupHeaderItem(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getFilteredItems() {
    return this.$$.ctx[66];
  }
  set getFilteredItems(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyles() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyles(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearable() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearable(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOpen() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOpen(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debounce() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debounce(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debounceWait() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debounceWait(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideEmptyState() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideEmptyState(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputAttributes() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputAttributes(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listAutoWidth() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listAutoWidth(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showChevron() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showChevron(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listOffset() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listOffset(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hoverItemIndex() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hoverItemIndex(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingConfig() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingConfig(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleClear() {
    return this.$$.ctx[22];
  }
  set handleClear(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaValues() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaValues(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaListOpen() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaListOpen(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaFocused() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaFocused(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;
export {
  Select_default as default
};
//# sourceMappingURL=svelte-select.js.map
